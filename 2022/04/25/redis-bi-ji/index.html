<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="Redis笔记, Jue-Blog">
    <meta name="description" content="Redis笔记和问题处理">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="referrer" content="no-referrer-when-downgrade">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>Redis笔记 | Jue-Blog</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">

    <script src="/libs/jquery/jquery-3.6.0.min.js"></script>

<meta name="generator" content="Hexo 6.1.0"><link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head>



   <style>
    body{
       background-image: url(/medias/featureimages/bg.jpg);
       background-repeat:no-repeat;
       background-size: 100% 100%;
       background-attachment:fixed;
    }
</style>



<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">Jue-Blog</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>留言板</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">Jue-Blog</div>
        <div class="logo-desc">
            
            Just do it！
            
        </div>
    </div>

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			留言板
		</a>
          
        </li>
        
        
    </ul>
</div>


        </div>

        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/17.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">Redis笔记</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        padding: 35px 0 15px 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        padding-bottom: 30px;
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;

        position: absolute;
        right: 23.5vw;
        display: block;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/DB/">
                                <span class="chip bg-color">DB</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/Redis/" class="post-category">
                                Redis
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2022-04-25
                </div>
                

                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-check fa-fw"></i>更新日期:&nbsp;&nbsp;
                    2022-04-25
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                    17.6k
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-clock fa-fw"></i>阅读时长:&nbsp;&nbsp;
                    67 分
                </div>
                

                
                    <div id="busuanzi_container_page_pv" class="info-break-policy">
                        <i class="far fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp;
                        <span id="busuanzi_value_page_pv"></span>
                    </div>
				
            </div>
        </div>
        <hr class="clearfix">

        

        
        <!-- 代码块折行 -->
        <style type="text/css">
            code[class*="language-"], pre[class*="language-"] { white-space: pre-wrap !important; }
        </style>
        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <hr>
<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><h3 id="Linux安装"><a href="#Linux安装" class="headerlink" title="Linux安装"></a>Linux安装</h3><p>企业种用的最多的部署方案还是Linux</p>
<p>先上传至&#x2F;opt下，然后解压至&#x2F;usr&#x2F;local</p>
<pre class=" language-bash"><code class="language-bash"><span class="token function">tar</span> -zxvf redis-6.2.6.tar.gz -C /usr/local/
</code></pre>
<p>进去redis目录</p>
<p>安装GCC</p>
<pre class=" language-bash"><code class="language-bash">yum <span class="token function">install</span> -y gcc
</code></pre>
<p>我们需要把源代码编译成可以执行的文件（redis根目录下）</p>
<p>编译完成，src就是编译完成后生成的目录</p>
<p><img src="/2022/04/25/redis-bi-ji/image-20220419200825015.png" alt="image-20220419200825015"></p>
<p>安装</p>
<p><img src="/2022/04/25/redis-bi-ji/image-20220419200914603.png" alt="image-20220419200914603"></p>
<p>进去src里面ls一下</p>
<p>然后就是文件作用，现在的话记住两个就行，一个是server，一个是cli</p>
<h4 id="服务启动"><a href="#服务启动" class="headerlink" title="服务启动"></a>服务启动</h4><h5 id="前台启动"><a href="#前台启动" class="headerlink" title="前台启动"></a>前台启动</h5><p>src下执行,端口为6379</p>
<pre class=" language-bash"><code class="language-bash">./redis-server
</code></pre>
<p><img src="/2022/04/25/redis-bi-ji/image-20220419201207779.png" alt="image-20220419201207779"></p>
<p><img src="/2022/04/25/redis-bi-ji/image-20220419201130113.png" alt="image-20220419201130113"></p>
<h5 id="后台启动"><a href="#后台启动" class="headerlink" title="后台启动"></a>后台启动</h5><p>修改redis.conf文件（回根目录）  257行左右  直接&#x2F;daemonize搜索就行</p>
<pre class=" language-none"><code class="language-none">daemonize yes    #由no改为yes
</code></pre>
<p>然后就可以后台运行了</p>
<p><img src="/2022/04/25/redis-bi-ji/image-20220419201558533.png" alt="image-20220419201558533"></p>
<p><img src="/2022/04/25/redis-bi-ji/image-20220419201644659.png" alt="image-20220419201644659"></p>
<p>然后也可以通过redis-cli连接到服务，这就说明单机版的redis就安装成功了</p>
<p><img src="/2022/04/25/redis-bi-ji/image-20220419201726223.png" alt="image-20220419201726223"></p>
<h3 id="Docker安装Redis"><a href="#Docker安装Redis" class="headerlink" title="Docker安装Redis"></a>Docker安装Redis</h3><p>先停一下之前的redis，直接kill -9 停掉</p>
<p><img src="/2022/04/25/redis-bi-ji/image-20220419201928012.png" alt="image-20220419201928012"></p>
<p>没安装docker就先y安装docker</p>
<p>yum -y install docker </p>
<p>然后启动一下docker</p>
<p>service docker start</p>
<p>直接拉一下redis</p>
<pre class=" language-none"><code class="language-none">docker pull redis
</code></pre>
<p>启动一下容器</p>
<pre class=" language-none"><code class="language-none">docker run -d --name myredis -p 6379:6379 redis
</code></pre>
<p>然后可以docker ps看一下</p>
<p>进去看看,然后再连一下，就很简单</p>
<pre class=" language-bash"><code class="language-bash">docker <span class="token function">exec</span> -it myredis /bin/bash
</code></pre>
<p><img src="/2022/04/25/redis-bi-ji/image-20220419202614073.png" alt="image-20220419202614073"></p>
<p>然后两次exit退出来</p>
<h2 id="基本知识"><a href="#基本知识" class="headerlink" title="基本知识"></a>基本知识</h2><p>Redis能读的速度是110000次&#x2F;s，写81000次&#x2F;s</p>
<h4 id="默认16数据库"><a href="#默认16数据库" class="headerlink" title="默认16数据库"></a>默认16数据库</h4><p>​        Redis是一个字典结构的存储服务器，一个Redis实例提供了多个用来存储数据的字典，客户端可以指定将数据存储在哪个字典中。</p>
<p>16数据库是可以在配置文件种找到的，配置文件的databases 给的就是16    </p>
<h5 id="Redis-使用的到底是多线程还是单线程？"><a href="#Redis-使用的到底是多线程还是单线程？" class="headerlink" title="Redis 使用的到底是多线程还是单线程？"></a>Redis 使用的到底是多线程还是单线程？</h5><p>单线程，瓶颈在内存大小或者网络带宽</p>
<p>​        因为Redis是基于内存的操作，CPU不是Redis的瓶颈，Redis的瓶颈最有可能是机器内存的大小或者网络 带宽。既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章地采用单线程的方案了。</p>
<h5 id="IO多路复用技术"><a href="#IO多路复用技术" class="headerlink" title="IO多路复用技术"></a>IO多路复用技术</h5><p>难讲，自己找找看吧</p>
<h5 id="切换数据库"><a href="#切换数据库" class="headerlink" title="切换数据库"></a>切换数据库</h5><p>select </p>
<p>不指定就会存0库</p>
<p><img src="/2022/04/25/redis-bi-ji/image-20220419210536436.png" alt="image-20220419210536436"></p>
<h5 id="清空数据库"><a href="#清空数据库" class="headerlink" title="清空数据库"></a>清空数据库</h5><p>flushdb  —-清除当前库</p>
<h5 id="删除所有库"><a href="#删除所有库" class="headerlink" title="删除所有库"></a>删除所有库</h5><p>flushall   </p>
<h3 id="Key键"><a href="#Key键" class="headerlink" title="Key键"></a>Key键</h3><h5 id="keys"><a href="#keys" class="headerlink" title="keys"></a>keys</h5><p>查看所有key</p>
<pre class=" language-none"><code class="language-none">keys *
</code></pre>
<p>有3个通配符 *, ? ,[] </p>
<p>*: 通配任意多个字符 </p>
<p>?: 通配单个字符 </p>
<p>[]: 通配括号内的某1个字符</p>
<h6 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h6><p>​    生产已经禁止。因为长时间阻塞redis而导致其他客户端的命令请求一直处于阻塞状态。 更安全的做法是采用scan。</p>
<pre class=" language-none"><code class="language-none">root@6c068b3fbf29:/data# redis-cli --scan "u*"
"user1"
"user
</code></pre>
<h5 id="exists"><a href="#exists" class="headerlink" title="exists"></a>exists</h5><p>判断某个key是否存在，返回1表示存在，0不存在。 </p>
<p>语法结构：</p>
<pre class=" language-bash"><code class="language-bash">exists key
</code></pre>
<p>示例：</p>
<pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true">#查看k1是否存在，如果存在返回1</span>
exists k1
<span class="token comment" spellcheck="true"># 查看k1 k2 k3是否存在，如果k1 k2存在，k3不存在，则返回2</span>
exists k1 k2 k3
</code></pre>
<h5 id="type"><a href="#type" class="headerlink" title="type"></a>type</h5><p>查看当前key 所储存的值的类型。返回当前key所储存的值的类型，如string 、list等。 </p>
<p>语法结构：</p>
<p>type key</p>
<h5 id="del"><a href="#del" class="headerlink" title="del"></a>del</h5><p>删除已存在的key，不存在的 key 会被忽略。</p>
<p>语法结构：</p>
<p>del key</p>
<p>示例： 可以设置多个key，返回删除成功的个数。</p>
<pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 删除k1，如果成功返回1，失败返回0</span>
del k1
<span class="token comment" spellcheck="true"># 删除k1 k2 k3，如果k1 k2存在，k3不存在，则返回2</span>
del k1 k2 k3
</code></pre>
<h5 id="expire"><a href="#expire" class="headerlink" title="expire"></a>expire</h5><p>给key设置time秒的过期时间。设置成功返回 1 。 当 key 不存在返回 0。</p>
<pre class=" language-bash"><code class="language-bash">expire key <span class="token function">time</span>
</code></pre>
<p>示例：</p>
<pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 给k1设置10秒后过期</span>
expire k1 10
</code></pre>
<h5 id="ttl"><a href="#ttl" class="headerlink" title="ttl"></a>ttl</h5><p>以秒为单位返回 key 的剩余过期时间。</p>
<p>ttl key</p>
<p>注意： 当 key 不存在时，返回 -2 。 当 key 存在但没有设置剩余生存时间时，返回 -1 。 否则，以秒为单 位，返回 key 的剩余生存时间。</p>
<h5 id="persist"><a href="#persist" class="headerlink" title="persist"></a>persist</h5><p>移除给定 key 的过期时间，使得 key 永不过期。</p>
<p>persist key</p>
<p>注意： 当过期时间移除成功时，返回 1 。 如果 key 不存在或 key 没有设置过期时间，返回 0 。</p>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p>最大字符串512M，但是非常不建议大字符串</p>
<h5 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h5><p>String是Redis最基本的类型，一个key对应一个value。String是二进制安全的，意味着String可以包含 任何数据，比如序列化对象或者一张图片。String最多可以放512M的数据。</p>
<h4 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h4><h5 id="set"><a href="#set" class="headerlink" title="set"></a>set</h5><p>用于设置给定 key 的值。如果 key 已经存储其他值， set 就重写旧值，且无视类型。</p>
<p>set key value</p>
<h5 id="get"><a href="#get" class="headerlink" title="get"></a>get</h5><p>用于获取指定 key 的值。如果 key 不存在，返回 nil 。</p>
<p>get key</p>
<h5 id="append"><a href="#append" class="headerlink" title="append"></a>append</h5><p>将给定的value追加到key原值末尾。 </p>
<p>语法格式:</p>
<pre class=" language-none"><code class="language-none">append key value
</code></pre>
<p>注意： </p>
<ul>
<li>如果 key 已经存在并且是一个字符串， append 命令将 value 追加到 key 原来的值的末尾。 </li>
<li>如果 key 不存在， append 就简单地将给定 key 设为 value ，就像执行 set key value 一 样</li>
</ul>
<h5 id="strlen"><a href="#strlen" class="headerlink" title="strlen"></a>strlen</h5><p>获取指定 key 所储存的字符串值的长度。当 key 储存的不是字符串值时，返回一个错误。</p>
<pre class=" language-none"><code class="language-none">strlen key
</code></pre>
<h5 id="setex"><a href="#setex" class="headerlink" title="setex"></a>setex</h5><p>给指定的 key 设置值及time 秒的过期时间。如果 key 已经存在， setex命令将会替换旧的值，并设置过 期时间。</p>
<pre class=" language-none"><code class="language-none">setex key time value
</code></pre>
<p>示例：</p>
<pre class=" language-none"><code class="language-none">#向Redis中设置一个k1的键值对并且10秒后过期
127.0.0.1:6379> setex k1 10 v1
OK
</code></pre>
<h5 id="setnx"><a href="#setnx" class="headerlink" title="setnx"></a>setnx</h5><pre class=" language-none"><code class="language-none">setnx key value
</code></pre>
<p>只有在key不存在时设置key的值</p>
<p>key存在就返回0，不存在返回1</p>
<p>这个功能实现分布式锁用的比较多</p>
<h5 id="getrange"><a href="#getrange" class="headerlink" title="getrange"></a>getrange</h5><p>获取指定区间范围内的值，类似between……..and 的关系</p>
<pre class=" language-none"><code class="language-none">getrange key start end
</code></pre>
<h5 id="setrange"><a href="#setrange" class="headerlink" title="setrange"></a>setrange</h5><p>​        从偏移量offset开始，覆写value（对于新的value长度如果小于旧值从offset到结束的长度时，长度小于的部分会保持不变），并返回当前value的长度</p>
<pre class=" language-bash"><code class="language-bash">setrange key offset value
</code></pre>
<p>从1开始计数</p>
<h5 id="incr"><a href="#incr" class="headerlink" title="incr"></a>incr</h5><pre class=" language-bash"><code class="language-bash">incr key
</code></pre>
<p>将 key 中储存的数字值增一。</p>
<p>注意： 如果 key 不存在，那么 key 的值会先被初始化为 0 ，然后再执行 incr 操作。 如字符串类型的值不能表示为数字、或者是其他类型，那么返回一个错误。</p>
<h5 id="incrby-x2F-decrby-key-step"><a href="#incrby-x2F-decrby-key-step" class="headerlink" title="incrby&#x2F;decrby key step"></a>incrby&#x2F;decrby key step</h5><pre class=" language-none"><code class="language-none"> incrby k1 10
</code></pre>
<p>将key存储的数字值按照step进行增减。</p>
<h5 id="mset"><a href="#mset" class="headerlink" title="mset"></a>mset</h5><p>同时设置一个或多个 key-value 。</p>
<pre class=" language-none"><code class="language-none">mset key1 value1 key2 value2
</code></pre>
<h5 id="mget"><a href="#mget" class="headerlink" title="mget"></a>mget</h5><p>返回所有(一个或多个)给定 key 的值。</p>
<p>mget key1 key2</p>
<p>注意: 如果给定的 key 里面，有某个 key 不存在，那么这个 key 返回特殊值 nil 。</p>
<h5 id="getset"><a href="#getset" class="headerlink" title="getset"></a>getset</h5><p>将给定key值设为value，并返回key的旧值（old value），简单一句话（先get然后立即set）。</p>
<p>getset key value</p>
<h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><h5 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h5><p>​        List是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右 边）。底层是一个双向链表，对两段操作性能极高，通过索引操作中间的节点性能较差。</p>
<p>​         一个List最多可以包含 $2^{32}-1$个元素 （ 每个列表超过40亿个元素）。</p>
<h4 id="常用命令-1"><a href="#常用命令-1" class="headerlink" title="常用命令"></a>常用命令</h4><h5 id="lpush-x2F-rpush"><a href="#lpush-x2F-rpush" class="headerlink" title="lpush&#x2F;rpush"></a>lpush&#x2F;rpush</h5><p>从左边（头部）&#x2F;右边（尾部）插入一个或多个值。</p>
<p>语法结构：</p>
<pre class=" language-none"><code class="language-none">lpush/rpush key1 value1 value2 value3……
</code></pre>
<p>如：#从左边放入v1 v2 v3</p>
<p>lpush k1 v1 v2 v3</p>
<p>#从右边放入v4 v5 v6</p>
<p>rpush k1 v4 v5 v6</p>
<p><img src="/2022/04/25/redis-bi-ji/image-20220425093418660.png" alt="image-20220425093418660"></p>
<h5 id="lrange"><a href="#lrange" class="headerlink" title="lrange"></a>lrange</h5><p>​        返回key列表中的start和end之间的元素（包含start和end）。 其中 0 表示列表的第一个元素，-1表示 最后一个元素。</p>
<pre class=" language-none"><code class="language-none">lrange key start end
</code></pre>
<p>示例：</p>
<pre class=" language-none"><code class="language-none">#取出列表里前3个值，结果为v3 v2 v1
127.0.0.1:6379> lrange k1 0 2
#取出列表里全部值，结果为v3 v2 v1 v4 v5 v6
127.0.0.1:6379> lrange k1 0 -1
</code></pre>
<h5 id="lpop-x2F-rpop"><a href="#lpop-x2F-rpop" class="headerlink" title="lpop&#x2F;rpop"></a>lpop&#x2F;rpop</h5><p>移除并返回第一个值或最后一个值。</p>
<pre class=" language-none"><code class="language-none">lpop/rpop key

lpop k1 从列表中删除v3，并返回，当前列表全部值v2 v1 v4 v5 v6
rpop k1 从列表中删除v6，并返回，当前列表全部值v2 v1 v4 v5
</code></pre>
<p>注意： 值在键在，值光键亡。</p>
<h5 id="lindex"><a href="#lindex" class="headerlink" title="lindex"></a>lindex</h5><p>获取列表index位置的值(从左开始  0开始计算)。</p>
<pre class=" language-none"><code class="language-none">lindex key index
</code></pre>
<h5 id="llen"><a href="#llen" class="headerlink" title="llen"></a>llen</h5><p>获取列表长度。</p>
<p>llen key</p>
<h5 id="lrem"><a href="#lrem" class="headerlink" title="lrem"></a>lrem</h5><p>从左边开始删除与value相同的count个元素。</p>
<pre class=" language-none"><code class="language-none">lrem key count value

#从左边开始删除k1列表中2个v1元素
lrem k1 2 v1
</code></pre>
<h5 id="linsert"><a href="#linsert" class="headerlink" title="linsert"></a>linsert</h5><p>在列表中value值的前边&#x2F;后边插入一个new value值（从左开始）。</p>
<pre class=" language-none"><code class="language-none">linsert key before/after value newvalue
#示例  在v1前面插入一个v5
linsert k1 before v1 v5 
</code></pre>
<h5 id="lset"><a href="#lset" class="headerlink" title="lset"></a>lset</h5><p>将索引为index的值设置为value</p>
<pre class=" language-none"><code class="language-none">lset key index value
</code></pre>
<h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><ul>
<li>消息队列 </li>
<li>排行榜 </li>
<li>最新列表</li>
</ul>
<h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p>Redis的Set是String类型的无序集合</p>
<h5 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h5><p>​        与List类似是一个列表功能，但Set是自动排重的，当需要存储一个列表数据，又不希望出现重复数据 时，Set是一个很好的选择。</p>
<p>​        Set是String类型的无序集合，它底层其实是一个value为null的hash表，所以添加、删除、查找的时间 复杂度都是O(1)</p>
<h4 id="常用命令-2"><a href="#常用命令-2" class="headerlink" title="常用命令"></a>常用命令</h4><h5 id="sadd"><a href="#sadd" class="headerlink" title="sadd"></a>sadd</h5><p>将一个或多个元素添加到集合key中，已经存在的元素将被忽略。</p>
<p><img src="/2022/04/25/redis-bi-ji/image-20220420161239626.png" alt="image-20220420161239626"></p>
<h5 id="smembers"><a href="#smembers" class="headerlink" title="smembers"></a>smembers</h5><p>取出该集合的所有元素。</p>
<p><img src="/2022/04/25/redis-bi-ji/image-20220420161344467.png" alt="image-20220420161344467"></p>
<h5 id="sismember"><a href="#sismember" class="headerlink" title="sismember"></a>sismember</h5><p>判断集合key中是否含有value元素，如有返回1，否则返回0。</p>
<p><img src="/2022/04/25/redis-bi-ji/image-20220420161429941.png" alt="image-20220420161429941"></p>
<h5 id="scard"><a href="#scard" class="headerlink" title="scard"></a>scard</h5><p>返回该集合的元素个数。</p>
<p><img src="/2022/04/25/redis-bi-ji/image-20220420161503192.png" alt="image-20220420161503192"></p>
<h5 id="srem"><a href="#srem" class="headerlink" title="srem"></a>srem</h5><p>删除集合中的一个或多个成员元素，不存在的成员元素会被忽略。</p>
<pre class=" language-none"><code class="language-none">srem key value1 value2……
</code></pre>
<p><img src="/2022/04/25/redis-bi-ji/image-20220420161533211.png" alt="image-20220420161533211"></p>
<h5 id="spop"><a href="#spop" class="headerlink" title="spop"></a>spop</h5><p>随机删除集合中一个元素并返回该元素。</p>
<p>spop key</p>
<p><img src="/2022/04/25/redis-bi-ji/image-20220420161630043.png" alt="image-20220420161630043"></p>
<h5 id="srandmember"><a href="#srandmember" class="headerlink" title="srandmember"></a>srandmember</h5><p>随机取出集合中count个元素，但不会删除。</p>
<pre class=" language-none"><code class="language-none">srandmember key count
</code></pre>
<h5 id="smove"><a href="#smove" class="headerlink" title="smove"></a>smove</h5><p>将value元素从sourcekey集合移动到destinationkey集合中。</p>
<pre class=" language-none"><code class="language-none">smove sourcekey destinationkey value
</code></pre>
<p>注意： 如果 sourcekey集合不存在或不包含指定的 value元素，则 smove 命令不执行任何操作，仅返回 0 。</p>
<h5 id="sinter"><a href="#sinter" class="headerlink" title="sinter"></a>sinter</h5><p>返回两个集合的交集元素。</p>
<pre class=" language-none"><code class="language-none">sinter key1 key2
</code></pre>
<h5 id="sunion"><a href="#sunion" class="headerlink" title="sunion"></a>sunion</h5><p>返回两个集合的并集元素。</p>
<pre class=" language-none"><code class="language-none">sunion key1 key2
</code></pre>
<h5 id="sdiff"><a href="#sdiff" class="headerlink" title="sdiff"></a>sdiff</h5><p>返回两个集合的差集元素（key1中的，不包含key2）</p>
<pre class=" language-none"><code class="language-none">sdiff key1 key2
</code></pre>
<h4 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h4><ul>
<li>黑白名单 </li>
<li>随机展示 </li>
<li>好友 </li>
<li>关注人 </li>
<li>粉丝 </li>
<li>感兴趣的人集合</li>
</ul>
<h3 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h3><p><img src="/2022/04/25/redis-bi-ji/image-20220425100900244.png" alt="image-20220425100900244"></p>
<h5 id="简介-3"><a href="#简介-3" class="headerlink" title="简介"></a>简介</h5><p>​        Hash是一个键值对的集合。Hash 是一个 String 类型的 field（字段） 和 value（值） 的映射表，hash 特别适合用于存储对象。</p>
<ul>
<li>Hash存储结构优化 <ul>
<li>如果field数量较少，存储结构优化为类数组结构 </li>
<li>如果field数量较多，存储结构使用HashMap结构</li>
</ul>
</li>
</ul>
<h4 id="常用命令-3"><a href="#常用命令-3" class="headerlink" title="常用命令"></a>常用命令</h4><h5 id="hset"><a href="#hset" class="headerlink" title="hset"></a>hset</h5><p>给key集合中的field赋值value。</p>
<pre class=" language-none"><code class="language-none">127.0.0.1:6379> hset user name JueJue
(integer) 1
127.0.0.1:6379> hset user age 3
(integer) 1
</code></pre>
<p>注意： </p>
<ul>
<li>如果哈希表不存在，一个新的哈希表被创建并进行HSET 操作。 </li>
<li>如果字段已经存在于哈希表中，旧值将被重写。</li>
</ul>
<h5 id="hget"><a href="#hget" class="headerlink" title="hget"></a>hget</h5><p>从key哈希中，取出field字段的值。</p>
<pre class=" language-none"><code class="language-none">hget key field
</code></pre>
<h5 id="hmset"><a href="#hmset" class="headerlink" title="hmset"></a>hmset</h5><p>批量设置哈希的字段及值。</p>
<pre class=" language-none"><code class="language-none">hmset key field1 value1 field2 value2……
</code></pre>
<h5 id="hexists"><a href="#hexists" class="headerlink" title="hexists"></a>hexists</h5><p>判断指定key中是否存在field  </p>
<pre class=" language-none"><code class="language-none">hexists key field
</code></pre>
<p>注意： </p>
<p>如果哈希表含有给定字段，返回 1 。 如果哈希表不含有给定字段，或 key 不存在，返回 0 。</p>
<h5 id="hkeys"><a href="#hkeys" class="headerlink" title="hkeys"></a>hkeys</h5><p>获取该哈希中所有的field。</p>
<pre class=" language-none"><code class="language-none">hkeys key
</code></pre>
<h5 id="hvals-key"><a href="#hvals-key" class="headerlink" title="hvals key"></a>hvals key</h5><p>获取该哈希中所有的value。</p>
<pre class=" language-none"><code class="language-none">hvals key
</code></pre>
<h5 id="hincrby"><a href="#hincrby" class="headerlink" title="hincrby"></a>hincrby</h5><p>为哈希表key中的field字段的值加上增量increment。</p>
<pre class=" language-none"><code class="language-none">hincrby key field increment
</code></pre>
<p>注意： </p>
<ul>
<li>增量也可以为负数，相当于对指定字段进行减法操作。 </li>
<li>如果哈希表的 key 不存在，一个新的哈希表被创建并执行 hincrby 命令。 </li>
<li>如果指定的字段不存在，那么在执行命令前，字段的值被初始化为 0 。 </li>
<li>对一个储存字符串值的字段执行 hincrby 命令将造成一个错误。</li>
</ul>
<p>hincrby user1 age 10 对user中的age字段做运算，增加10</p>
<h5 id="hdel"><a href="#hdel" class="headerlink" title="hdel"></a>hdel</h5><p>删除哈希表 key 中的一个或多个指定字段，不存在的字段将被忽略。</p>
<pre class=" language-none"><code class="language-none">hdel key field1 field2……
</code></pre>
<h5 id="hsetnx"><a href="#hsetnx" class="headerlink" title="hsetnx"></a>hsetnx</h5><p>给key哈希表中不存在的的字段赋值 。</p>
<pre class=" language-none"><code class="language-none">hsetnx key field value
</code></pre>
<p>注意： </p>
<ul>
<li>如果哈希表不存在，一个新的哈希表被创建并进行 hsetnx 操作。 </li>
<li>如果字段已经存在于哈希表中，操作无效。 </li>
<li>如果 key 不存在，一个新哈希表被创建并执行 hsetnx 命令。</li>
</ul>
<h4 id="使用场景-2"><a href="#使用场景-2" class="headerlink" title="使用场景"></a>使用场景</h4><ul>
<li>购物车 </li>
<li>存储对象</li>
</ul>
<h3 id="Zset"><a href="#Zset" class="headerlink" title="Zset"></a>Zset</h3><h5 id="简介-4"><a href="#简介-4" class="headerlink" title="简介"></a>简介</h5><p>​        Zset与Set非常相似，是一个没有重复元素的String集合。不同之处是Zset的每个元素都关联了一个分数 （score），这个分数被用来按照从低分到高分的方式排序集合中的元素。集合的元素是唯一的，但分数 可以重复。</p>
<p>注意： 因为元素是有序的，所以可以根据分数（score）或者次序（position）来获取一个范围内的元素。</p>
<h4 id="常用命令-4"><a href="#常用命令-4" class="headerlink" title="常用命令"></a>常用命令</h4><h5 id="zadd"><a href="#zadd" class="headerlink" title="zadd"></a>zadd</h5><p>将一个或多个元素（value）及分数（score）加入到有序集key中。</p>
<pre class=" language-none"><code class="language-none">zadd key score1 value1 score2 value2…… 
</code></pre>
<h6 id="注意：-1"><a href="#注意：-1" class="headerlink" title="注意："></a>注意：</h6><ul>
<li>如果某个元素已经是有序集的元素，那么更新这个元素的分数值，并通过重新插入这个元 素，来保证该元素在正确的位置上。 </li>
<li>分数值可以是整数值或双精度浮点数。 </li>
<li>如果有序集合 key 不存在，则创建一个空的有序集并执行 zadd 操作。</li>
</ul>
<h5 id="zrange"><a href="#zrange" class="headerlink" title="zrange"></a>zrange</h5><p>返回key集合中的索引start和索引end之间的元素（包含start和end）。</p>
<pre class=" language-none"><code class="language-none">zrange key start end [withscores]

# 示例
zrange k1 0 -1 返回集合中所有元素
zrange k1 0 -1 withscores 返回集合中所有元素，并携带元素分数
</code></pre>
<p>注意： </p>
<ul>
<li>其中元素的位置按分数值递增(从小到大)来排序。 其中 0 表示列表的第一个元素，-1表示最 后一个元素。 </li>
<li>withscores是可选参数，是否返回分数</li>
</ul>
<h5 id="zrangebyscore"><a href="#zrangebyscore" class="headerlink" title="zrangebyscore"></a>zrangebyscore</h5><p>​        返回key集合中的分数minscore和分数maxscore 之间的元素（包含minscore 和maxscore ）。其中元素的位置按分数值递增(从小到大)来排序。</p>
<p>​        withscores是可选参数，是否返回分数</p>
<pre class=" language-none"><code class="language-none">zrangebyscore key minscore maxscore [withscores]
</code></pre>
<h5 id="zincrby"><a href="#zincrby" class="headerlink" title="zincrby"></a>zincrby</h5><p>为元素value的<strong>score</strong>加上<strong>increment</strong>的值。</p>
<pre class=" language-none"><code class="language-none">zincrby key increment value

zincrby k1 50 java 给java元素加上50分
</code></pre>
<h5 id="zrem"><a href="#zrem" class="headerlink" title="zrem"></a>zrem</h5><p>删除该集合下value的元素。</p>
<pre class=" language-none"><code class="language-none">zrem k1 php 删除php
</code></pre>
<h5 id="zcount"><a href="#zcount" class="headerlink" title="zcount"></a>zcount</h5><p>统计该集合在minscore 到maxscore分数区间中元素的个数。</p>
<pre class=" language-none"><code class="language-none">zcount key minscore maxscore
</code></pre>
<h5 id="zrank"><a href="#zrank" class="headerlink" title="zrank"></a>zrank</h5><p>返回value在集合中的排名，从0开始。</p>
<pre class=" language-none"><code class="language-none">zrank key value
</code></pre>
<h4 id="使用场景-3"><a href="#使用场景-3" class="headerlink" title="使用场景"></a>使用场景</h4><ul>
<li>延时队列 </li>
<li>排行榜 </li>
<li>限流</li>
</ul>
<h3 id="Bitmaps"><a href="#Bitmaps" class="headerlink" title="Bitmaps"></a>Bitmaps</h3><p>Bitmaps本身不是一种数据结构，实际上就是字符串，但是它可以对字符串的位进行操作</p>
<h5 id="简介-5"><a href="#简介-5" class="headerlink" title="简介"></a>简介</h5><p>​        在计算机中，用二进制（位）作为存储信息的基本单位，1个字节等于8位。 例如 “abc” 字符串是由 3 个字节组成，计算机存储时使用其二进制表示，”abc”分别对应的ASCII码是 97、98、99，对应的二进制是01100001、01100010、01100011，在内存中表示如下：</p>
<p><img src="/2022/04/25/redis-bi-ji/image-20220425111357601.png" alt="image-20220425111357601"></p>
<p>合理地使用位能够有效地提高内存使用率和开发效率。 </p>
<p>Redis提供了Bitmaps这个 “数据结构” 可以实现对位的操作：</p>
<h4 id="常用命令-5"><a href="#常用命令-5" class="headerlink" title="常用命令"></a>常用命令</h4><h5 id="setbit"><a href="#setbit" class="headerlink" title="setbit"></a>setbit</h5><p>设置Bitmaps中某个偏移量的值。</p>
<pre class=" language-none"><code class="language-none">setbit key offset value
</code></pre>
<h5 id="getbit"><a href="#getbit" class="headerlink" title="getbit"></a>getbit</h5><p>获取Bitmaps中某个偏移量的值。</p>
<pre class=" language-none"><code class="language-none">getbit key offset
</code></pre>
<p> 如果偏移量未设置值，则也返回0。</p>
<h5 id="bitcount"><a href="#bitcount" class="headerlink" title="bitcount"></a>bitcount</h5><p>​        统计字符串被设置为1的bit数量。一般情况下，给定的整个字符串都会被进行统计，可以选择通过额外 的start和end参数，指定字节组范围内进行统计（包括start和end），0表示第一个元素，-1表示最后一 个元素。</p>
<pre class=" language-none"><code class="language-none">bitcount key [start end]
</code></pre>
<h5 id="bitop"><a href="#bitop" class="headerlink" title="bitop"></a>bitop</h5><p>将多个bitmaps通过求交集&#x2F;并集方式合并成一个新的bitmaps。</p>
<pre class=" language-none"><code class="language-none">bitop and/or destkey sourcekey1 sourcekey2……
</code></pre>
<h4 id="使用场景-4"><a href="#使用场景-4" class="headerlink" title="使用场景"></a>使用场景</h4><ul>
<li>活跃天数 </li>
<li>打卡天数 </li>
<li>登录天数 </li>
<li>用户签到 </li>
<li>统计活跃用户 </li>
<li>统计用户是否在线 </li>
<li>实现布隆过滤器</li>
</ul>
<h3 id="Geospatia"><a href="#Geospatia" class="headerlink" title="Geospatia"></a>Geospatia</h3><h5 id="简介-6"><a href="#简介-6" class="headerlink" title="简介"></a>简介</h5><p>​        GEO，Geographic,地理信息的缩写。该类型就是元素的二维坐标，在地图上就是经纬度。Redis基于该 类型，提供了经纬度设置、查询、范围查询、距离查询、经纬度Hash等常见操作。</p>
<h4 id="常用命令-6"><a href="#常用命令-6" class="headerlink" title="常用命令"></a>常用命令</h4><h5 id="geoadd"><a href="#geoadd" class="headerlink" title="geoadd"></a>geoadd</h5><p>​        用于存储指定的地理空间位置，可以将一个或多个经度(longitude)、纬度(latitude)、位置名称 (member)添加到指定的 key 中。</p>
<pre class=" language-none"><code class="language-none">geoadd key longitude latitude member

# 将北京的经纬度和名称添加到china
geoadd china 116.405285 39.904989 beijing
# 将成都和上海的经纬度、名称添加到china
geoadd china 104.065735 30.659462 chengdu 121.472644 31.231706 shanghai
</code></pre>
<h5 id="geopos"><a href="#geopos" class="headerlink" title="geopos"></a>geopos</h5><p>从给定的 key 里返回所有指定名称(member)的位置（经度和纬度），不存在的返回 nil。</p>
<pre class=" language-none"><code class="language-none">geopos key member [member ……]
##返回china中名称为shanghai和beijing的经纬度
geopos chinacity shanghai beijing
</code></pre>
<h5 id="geodist"><a href="#geodist" class="headerlink" title="geodist"></a>geodist</h5><p>用于返回两个给定位置之间的距离。</p>
<pre class=" language-none"><code class="language-none">geodist key member1 member2 [m|km|ft|mi]
</code></pre>
<p>参数说明： </p>
<p>m ：米，默认单位。 </p>
<p>km ：千米。 </p>
<p>mi ：英里。 </p>
<p>ft ：英尺。</p>
<h5 id="georadius"><a href="#georadius" class="headerlink" title="georadius"></a>georadius</h5><p>​        以给定的经纬度（longitude latitude）为中心， 返回键包含的位置元素当中， 与中心的距离不超过给 定最大距离（radius ）的所有位置元素。</p>
<pre class=" language-none"><code class="language-none">georadius key longitude latitude radius m|km|ft|mi

#获取经纬度110 30为中心，在china内1200公里范围内的所有元素。
georadius china 110 30 1200 km
</code></pre>
<h4 id="使用场景-5"><a href="#使用场景-5" class="headerlink" title="使用场景"></a>使用场景</h4><ul>
<li>附近的电影院 </li>
<li>附近的好友 </li>
<li>离最近的火锅店</li>
</ul>
<h3 id="Hyperloglog"><a href="#Hyperloglog" class="headerlink" title="Hyperloglog"></a>Hyperloglog</h3><h5 id="简介-7"><a href="#简介-7" class="headerlink" title="简介"></a>简介</h5><p>​        在我们做站点流量统计的时候一般会统计页面UV(独立访客:unique visitor)和PV(即页面浏览量：page view)。redis HyperLogLog是用来做基数统计的算法，HyperLogLog的优点是：在输入元素的数量或者 体积非常非常大时，计算基数所需的空间总是固定的、并且使很小的。</p>
<h6 id="什么是基数"><a href="#什么是基数" class="headerlink" title="什么是基数"></a>什么是基数</h6><p>​        比如数据集{1,3,5,7,5,7,8}，那么这个数据集的基数集为{1,3,5,7,8},基数(不重复元素)为5.基数估计就是在 误差可接受的范围内，快速计算基数。</p>
<h4 id="常用命令-7"><a href="#常用命令-7" class="headerlink" title="常用命令"></a>常用命令</h4><h5 id="pfadd"><a href="#pfadd" class="headerlink" title="pfadd"></a>pfadd</h5><p>将所有元素参数添加到 Hyperloglog 数据结构中。</p>
<p>如果至少有个元素被添加返回 1， 否则返回 0。</p>
<pre class=" language-none"><code class="language-none">pfadd key element1 element2……

pfadd book1 uid1 uid2 uid3
</code></pre>
<p>注意： 添加元素到HyperLogLog中，如果内部有变动返回1，没有返回0。</p>
<h5 id="pfcount"><a href="#pfcount" class="headerlink" title="pfcount"></a>pfcount</h5><p>计算Hyperloglog 近似基数，可以计算多个Hyperloglog ，统计基数总数。</p>
<pre class=" language-none"><code class="language-none">pfcount key1 key2……
</code></pre>
<h5 id="pfmerge"><a href="#pfmerge" class="headerlink" title="pfmerge"></a>pfmerge</h5><p>将一个或多个Hyperloglog（sourcekey1） 合并成一个Hyperloglog （destkey ）。</p>
<pre class=" language-none"><code class="language-none">pfmerge destkey sourcekey1 sourcekey2……
</code></pre>
<h4 id="使用场景-6"><a href="#使用场景-6" class="headerlink" title="使用场景"></a>使用场景</h4><p>​        基数不大，数据量不大就用不上，会有点大材小用浪费空间，有局限性，就是只能统计基数数量，而没 办法去知道具体的内容是什么，和bitmap相比，属于两种特定统计情况，简单来说，HyperLogLog 去 重比 bitmaps 方便很多，一般可以bitmap和hyperloglog配合使用，bitmap标识哪些用户活跃。</p>
<ul>
<li>网站PV统计 </li>
<li>网站UV统计 </li>
<li>统计访问量(IP数) </li>
<li>统计在线用户数 </li>
<li>统计每天搜索不同词条的个数 </li>
<li>统计文章真实阅读数</li>
</ul>
<h3 id="可视化工具"><a href="#可视化工具" class="headerlink" title="可视化工具"></a>可视化工具</h3><p>直接安装就行</p>
<p>关闭防火墙也还是连接不上，但是我直接连上去了，我是防火墙一直关着，然后只是端口给错了才没连上</p>
<p><img src="/2022/04/25/redis-bi-ji/image-20220420190437878.png" alt="image-20220420190437878"></p>
<p>视频里关闭防火墙连不上说是只允许本地访问，要修改配置文件才能远程访问</p>
<p>是不是我虚拟机配置了本地的ip就给了windows</p>
<p>注释掉这个</p>
<p><img src="/2022/04/25/redis-bi-ji/image-20220420190651893.png" alt="image-20220420190651893"></p>
<p>关掉安全模式后重启</p>
<p><img src="/2022/04/25/redis-bi-ji/image-20220420190838527.png" alt="image-20220420190838527"></p>
<p>搞错了，，md一直连接的是docker里的，然后docker里的好像也不用配置就可以直接远程连接上，我说这么管理界面的数据和虚拟机的数据不一样。</p>
<h3 id="Java整合Redis-Jedis"><a href="#Java整合Redis-Jedis" class="headerlink" title="Java整合Redis_Jedis"></a>Java整合Redis_Jedis</h3><p>？？？为什么文档没有这玩意，直接就到压测了</p>
<p>手写吧</p>
<p>创建maven项目，添加依赖</p>
<pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>redis.clients<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>jedis<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>3.6.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>junit<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>junit<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>4.13.2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">></span></span>test<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>
</code></pre>
<p>运行成功</p>
<p><img src="/2022/04/25/redis-bi-ji/image-20220420202933246.png" alt="image-20220420202933246"></p>
<p><img src="/2022/04/25/redis-bi-ji/image-20220420202949899.png" alt="image-20220420202949899"></p>
<p>list操作</p>
<p>一点问题没有</p>
<p><img src="/2022/04/25/redis-bi-ji/image-20220420203616406.png" alt="image-20220420203616406"></p>
<p>Set</p>
<p><img src="/2022/04/25/redis-bi-ji/image-20220420204038939.png" alt="image-20220420204038939"></p>
<p>hash</p>
<p><img src="/2022/04/25/redis-bi-ji/image-20220420210058735.png" alt="image-20220420210058735"></p>
<p>zset</p>
<p><img src="/2022/04/25/redis-bi-ji/image-20220420210441400.png" alt="image-20220420210441400"></p>
<p>bitmaps</p>
<p><img src="/2022/04/25/redis-bi-ji/image-20220420211514033.png" alt="image-20220420211514033"></p>
<p>geo</p>
<p><img src="/2022/04/25/redis-bi-ji/image-20220420212002745.png" alt="image-20220420212002745"></p>
<p>hyperloglog</p>
<p><img src="/2022/04/25/redis-bi-ji/image-20220420212232637.png" alt="image-20220420212232637"></p>
<h3 id="Java整合Redis-Spring-Data-Redis"><a href="#Java整合Redis-Spring-Data-Redis" class="headerlink" title="Java整合Redis_Spring-Data-Redis"></a>Java整合Redis_Spring-Data-Redis</h3><h3 id="简介-8"><a href="#简介-8" class="headerlink" title="简介"></a>简介</h3><p>Spring-Data-Redis是spring大家族的一部分，通过简单的配置访问Redis服务，对Reids底层开发包(Jedis, JRedis, and RJC)进行了高度封装，RedisTemplate提供了Redis各种操作、异常处理及序列化，支持发布订阅。</p>
<h3 id="RedisTemplate介绍"><a href="#RedisTemplate介绍" class="headerlink" title="RedisTemplate介绍"></a><strong>RedisTemplate介绍</strong></h3><p>Spring封装了RedisTemplate对象来进行对Redis的各种操作，它支持所有的Redis原生的api。</p>
<pre class=" language-none"><code class="language-none">1
org.springframework.data.redis.core
2
Class RedisTemplate<K,V>
</code></pre>
<blockquote>
<p>  <strong>注意：</strong></p>
<ul>
<li><strong>K</strong>：模板中的Redis key的类型，模板中的Redis key的类型（通常为String）如：RedisTemplate&lt;String, Object&gt;。</li>
<li><strong>V</strong>：模板中的Redis value的类型</li>
</ul>
</blockquote>
<h3 id="RedisTemplate中定义了对5种数据结构操作"><a href="#RedisTemplate中定义了对5种数据结构操作" class="headerlink" title="RedisTemplate中定义了对5种数据结构操作"></a><strong>RedisTemplate中定义了对5种数据结构操作</strong></h3><pre class=" language-JAVA"><code class="language-JAVA">redisTemplate.opsForValue();//操作字符串

redisTemplate.opsForHash();//操作hash

redisTemplate.opsForList();//操作list

redisTemplate.opsForSet();//操作set

redisTemplate.opsForZSet();//操作有序set
</code></pre>
<h3 id="StringRedisTemplate与RedisTemplate"><a href="#StringRedisTemplate与RedisTemplate" class="headerlink" title="StringRedisTemplate与RedisTemplate"></a><strong>StringRedisTemplate与RedisTemplate</strong></h3><ul>
<li><p>两者的关系是StringRedisTemplate继承RedisTemplate。</p>
</li>
<li><p>两者的数据是不共通的；也就是说StringRedisTemplate只能管理StringRedisTemplate里面的数据，RedisTemplate只能管理RedisTemplate中的数据。</p>
</li>
<li><p>SDR默认采用的序列化策略有两种，一种是String的序列化策略，一种是JDK的序列化策略。</p>
<p>StringRedisTemplate默认采用的是String的序列化策略，保存的key和value都是采用此策略序列化保存的。</p>
<p>RedisTemplate默认采用的是JDK的序列化策略，保存的key和value都是采用此策略序列化保存的。</p>
</li>
</ul>
<p>测试方法写这一行</p>
<pre class=" language-none"><code class="language-none">redisTemplate.opsForValue().set("key1","value1");
</code></pre>
<p>因为序列化方式不同，这种方式使用的是JDK的序列化 </p>
<p><img src="/2022/04/25/redis-bi-ji/image-20220421094909095.png" alt="image-20220421094909095"></p>
<p>加了配置类改序列化就好了</p>
<p>自定义序列化类</p>
<pre class=" language-JAVA"><code class="language-JAVA">package com.jian.spirngdataredisdemo.conf;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.redis.connection.RedisConnectionFactory;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.data.redis.serializer.GenericJackson2JsonRedisSerializer;
import org.springframework.data.redis.serializer.StringRedisSerializer;

/**
 * 自定义序列化
 */
@Configuration
public class RedisConfig &#123;


    @Bean
    public RedisTemplate<String, Object> redisTemplate(RedisConnectionFactory redisConnectionFactory)&#123;
        RedisTemplate<String, Object> redisTemplate = new RedisTemplate<>();
        //添加序列化机制
        redisTemplate.setKeySerializer(new StringRedisSerializer());
        redisTemplate.setValueSerializer(new GenericJackson2JsonRedisSerializer());
        redisTemplate.setHashKeySerializer(new StringRedisSerializer());
        redisTemplate.setHashValueSerializer(new GenericJackson2JsonRedisSerializer());

        redisTemplate.setConnectionFactory(redisConnectionFactory);
        return redisTemplate;
    &#125;
&#125;
</code></pre>
<p><img src="/2022/04/25/redis-bi-ji/image-20220421102104191.png" alt="image-20220421102104191"></p>
<p>添加List</p>
<p><img src="/2022/04/25/redis-bi-ji/image-20220421102453038.png" alt="image-20220421102453038"></p>
<p>hash</p>
<p><img src="/2022/04/25/redis-bi-ji/image-20220421102933751.png" alt="image-20220421102933751"></p>
<p>set</p>
<p><img src="/2022/04/25/redis-bi-ji/image-20220421103247187.png" alt="image-20220421103247187"></p>
<p>zSet</p>
<p><img src="/2022/04/25/redis-bi-ji/image-20220421104619834.png" alt="image-20220421104619834"></p>
<p>不多说了</p>
<pre class=" language-JAVA"><code class="language-JAVA">    /**
     * 测试RedisTemplate操作redis服务
     */
    @Test
    public void test()&#123;
        //保存数据
        redisTemplate.opsForValue().set("key1","value1");
        //获取数据
        redisTemplate.opsForValue().get("key1");
    &#125;

    @Test
    void ListTest()&#123;
//        redisTemplate.opsForList().rightPush("k2","v1");
//        redisTemplate.opsForList().rightPush("k2","v2");
//        redisTemplate.opsForList().rightPush("k2","v3");
//        redisTemplate.opsForList().rightPush("k2","v4");
        //获取元素
        String k2 = (String) redisTemplate.opsForList().rightPop("k2");
        System.out.println(k2);
    &#125;

    /**
     * hash操作
     */
    @Test
    public void hashTest()&#123;
//        redisTemplate.opsForHash().put("user","name","JueJue");
//        redisTemplate.opsForHash().put("user","age","20");

        //获取元素
        String s = (String) redisTemplate.opsForHash().get("user", "name");
        System.out.println(s);
    &#125;

    /**
     * set操作
     */
    @Test
    public void setTest()&#123;
//        redisTemplate.opsForSet().add("sss1","vvv1");
//        redisTemplate.opsForSet().add("sss1","v2");
//        redisTemplate.opsForSet().add("sss1","v2");
//        redisTemplate.opsForSet().add("sss1","v3");

        //获取数据
        Set s = redisTemplate.opsForSet().members("sss1");
        for (Object o : s) &#123;
            System.out.println(o.toString());
        &#125;
        //获取set集合长度
        System.out.println(redisTemplate.opsForSet().size("sss1"));

    &#125;

    @Test
    public void zsetTest()&#123;
        //添加元素
//        redisTemplate.opsForZSet().add("z1","Java",66);
//        redisTemplate.opsForZSet().add("z1","C",67);
//        redisTemplate.opsForZSet().add("z1","C++",68);

        //获取元素
        Set k1 = redisTemplate.opsForZSet().range("z1", 0, -1);

        for (Object o : k1) &#123;
            System.out.println(o);
        &#125;
        System.out.println("-------------------------");
        Set set = redisTemplate.opsForZSet().rangeByScore("z1", 60, 67);
        for (Object o : set) &#123;
            System.out.println(o);
        &#125;


    &#125;
</code></pre>
<h2 id="Redis构建Web应用-网页缓存"><a href="#Redis构建Web应用-网页缓存" class="headerlink" title="Redis构建Web应用_网页缓存"></a>Redis构建Web应用_网页缓存</h2><p>就是用户发请求到nginx，然后反向代理负载均衡发到tomcat，之前没有加缓存，就会直接查询数据库</p>
<p>​        加了之后，请求到了；就会判断缓存中有没有，有就直接返回，没有就走数据库查询，如果数据库中有就把数据加到缓存中，下次查就有缓存了</p>
<p>创建springboot项目</p>
<p>写好之后，启动项目就会帮我们创建表</p>
<p><img src="/2022/04/25/redis-bi-ji/image-20220421152448503.png" alt="image-20220421152448503"></p>
<p>然后随便添加一条数据，去浏览器地址栏访问</p>
<p><img src="/2022/04/25/redis-bi-ji/image-20220421152747515.png" alt="image-20220421152747515"></p>
<p>上代码</p>
<pre class=" language-JAVA"><code class="language-JAVA">public GoodsEntity getById2(Long id)&#123;
        //从数据库中查询商品信息
        Optional<GoodsEntity> optionalGoodsEntity = goodsRepository.findById(id);
        if (optionalGoodsEntity.isPresent())&#123;
            return optionalGoodsEntity.get();
        &#125;
    return null;
&#125;
</code></pre>
<p>这个就是没有缓存的，那它的并发有多少呢？我们也不知道，所以 用一个压测的工具试一试（Jmeter）</p>
<p>使用</p>
<p>bin下运行这个</p>
<p><img src="/2022/04/25/redis-bi-ji/image-20220421190842291.png" alt="image-20220421190842291"></p>
<p>新建线程组，然后写线程数和循环数，我就是1000*10&#x3D;10000了</p>
<p>然后还是右键新建取样器Http请求和监听器的报告</p>
<p><img src="/2022/04/25/redis-bi-ji/image-20220421190123297.png" alt="image-20220421190123297"><img src="/2022/04/25/redis-bi-ji/image-20220421190321543.png" alt="image-20220421190321543"></p>
<p><img src="/2022/04/25/redis-bi-ji/image-20220421190934598.png" alt="image-20220421190934598"></p>
<p><img src="/2022/04/25/redis-bi-ji/image-20220421190246781.png" alt="image-20220421190246781"></p>
<p>一万并发达到4000（没有加缓存）</p>
<p><img src="/2022/04/25/redis-bi-ji/image-20220421183607570.png" alt="image-20220421183607570"></p>
<p>写好之后，重启先去浏览器发起一次请求</p>
<pre class=" language-JAVA"><code class="language-JAVA">@Autowired
private StringRedisTemplate stringRedisTemplate;

/**
 * 根据id查询商品信息
 * @param id 商品id
 * @return
 */
public GoodsEntity getById(Long id)&#123;

    //查询缓存
    String goodsString = stringRedisTemplate.opsForValue().get("goods:" + id);
    //判定有没有缓存
    if (StringUtils.isEmpty(goodsString))&#123;
        //从数据库中查询商品信息
        Optional<GoodsEntity> optionalGoodsEntity = goodsRepository.findById(id);
        if (optionalGoodsEntity.isPresent())&#123;
            GoodsEntity goodsEntity = optionalGoodsEntity.get();
            //对象转Json字符串（fastJson）
            String goodsEntityJson = JSON.toJSONString(goodsEntity);
            //添加缓存
            stringRedisTemplate.opsForValue().set("goods:" + id,goodsEntityJson);
            //保存完缓存了，就可以返回了
            return goodsEntity;
        &#125;
    &#125;else &#123;
        //把字符串转对象
        GoodsEntity goodsEntity = JSON.parseObject(goodsString, GoodsEntity.class);
        return goodsEntity;
    &#125;
    return null;
&#125;
</code></pre>
<p>然后去redis管理页面就可以看见刚刚加的缓存</p>
<p><img src="/2022/04/25/redis-bi-ji/image-20220421185105903.png" alt="image-20220421185105903"></p>
<p>然后进行压力测试</p>
<p>先清除一下</p>
<p><img src="/2022/04/25/redis-bi-ji/image-20220421185312803.png" alt="image-20220421185312803"></p>
<p>屌炸了，牛逼</p>
<p><img src="/2022/04/25/redis-bi-ji/image-20220421185350415.png" alt="image-20220421185350415"></p>
<p>再测试几次甚至能到9817</p>
<p>配置文件</p>
<pre class=" language-properties"><code class="language-properties"><span class="token comment" spellcheck="true">########################################################</span>
<span class="token comment" spellcheck="true">### 配置连接池数据库访问配置</span>
<span class="token comment" spellcheck="true">########################################################</span>
<span class="token attr-name">spring.datasource.driver-class-name</span><span class="token punctuation">=</span><span class="token attr-value">com.mysql.jdbc.Driver</span>
<span class="token attr-name">spring.datasource.url</span><span class="token punctuation">=</span><span class="token attr-value">jdbc:mysql://localhost:3306/goods?characterEncoding=utf-8&amp;&amp;useSSL=false</span>
<span class="token attr-name">spring.datasource.username</span><span class="token punctuation">=</span><span class="token attr-value">root</span>
<span class="token attr-name">spring.datasource.password</span><span class="token punctuation">=</span><span class="token attr-value">123456</span>
<span class="token comment" spellcheck="true"># 初始化大小，最小，最大</span>
<span class="token comment" spellcheck="true">#spring.datasource.initialSize=5</span>
<span class="token comment" spellcheck="true">#spring.datasource.minIdle=5</span>
<span class="token comment" spellcheck="true">#spring.datasource.maxActive=20</span>
<span class="token comment" spellcheck="true"># 配置获取连接等待超时的时间</span>
<span class="token comment" spellcheck="true">#spring.datasource.maxWait=60000</span>
<span class="token comment" spellcheck="true"># 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒</span>
<span class="token comment" spellcheck="true">#spring.datasource.timeBetweenEvictionRunsMillis=60000</span>
<span class="token comment" spellcheck="true"># 配置一个连接在池中最小生存的时间，单位是毫秒</span>
<span class="token comment" spellcheck="true">#spring.datasource.minEvictableIdleTimeMillis=300000</span>
<span class="token comment" spellcheck="true">#spring.datasource.validationQuery=SELECT 1 FROM DUAL</span>
<span class="token comment" spellcheck="true">#spring.datasource.testWhileIdle=true</span>
<span class="token comment" spellcheck="true">#spring.datasource.testOnBorrow=false</span>
<span class="token comment" spellcheck="true">#spring.datasource.testOnReturn=false</span>
<span class="token comment" spellcheck="true"># 打开PSCache，并且指定每个连接上PSCache的大小</span>
<span class="token comment" spellcheck="true">#spring.datasource.poolPreparedStatements=true</span>
<span class="token comment" spellcheck="true">#spring.datasource.maxPoolPreparedStatementPerConnectionSize=20</span>
<span class="token comment" spellcheck="true"># 配置监控统计拦截的filters，去掉后监控界面sql无法统计，'wall'用于防火墙</span>
<span class="token comment" spellcheck="true">#spring.datasource.filters=stat,wall,log4j</span>
<span class="token comment" spellcheck="true"># 通过connectProperties属性来打开mergeSql功能；慢SQL记录</span>
<span class="token comment" spellcheck="true">#spring.datasource.connectionProperties=druid.stat.mergeSql=true;druid.stat.slowSqlMillis=5000</span>
<span class="token comment" spellcheck="true"># 合并多个DruidDataSource的监控数据</span>
<span class="token comment" spellcheck="true">#spring.datasource.useGlobalDataSourceStat=true</span>
<span class="token comment" spellcheck="true">########################################################</span>
<span class="token comment" spellcheck="true">### Java Persistence Api --y   JPA配置</span>
<span class="token comment" spellcheck="true">########################################################</span>
<span class="token comment" spellcheck="true"># Specify the DBMS</span>
<span class="token attr-name">spring.jpa.database</span> <span class="token punctuation">=</span> <span class="token attr-value">MYSQL</span>
<span class="token comment" spellcheck="true"># Show or not log for each sql query</span>
<span class="token attr-name">spring.jpa.show-sql</span> <span class="token punctuation">=</span> <span class="token attr-value">true</span>
<span class="token comment" spellcheck="true"># Hibernate ddl auto (create, create-drop, update)</span>
<span class="token attr-name">spring.jpa.hibernate.ddl-auto</span> <span class="token punctuation">=</span> <span class="token attr-value">update</span>
<span class="token comment" spellcheck="true"># Naming strategy</span>
<span class="token comment" spellcheck="true">#[org.hibernate.cfg.ImprovedNamingStrategy  #org.hibernate.cfg.DefaultNamingStrategy]</span>
<span class="token attr-name">spring.jpa.hibernate.naming-strategy</span> <span class="token punctuation">=</span> <span class="token attr-value">org.hibernate.cfg.ImprovedNamingStrategy</span>
<span class="token comment" spellcheck="true"># stripped before adding them to the entity manager)</span>
<span class="token attr-name">spring.jpa.properties.hibernate.dialect</span> <span class="token punctuation">=</span> <span class="token attr-value">org.hibernate.dialect.MySQL5Dialect</span>
<span class="token comment" spellcheck="true">########################################################</span>
<span class="token comment" spellcheck="true">### 配置连接池数据库访问配置</span>
<span class="token comment" spellcheck="true">########################################################</span>
<span class="token comment" spellcheck="true">#Redis服务器连接地址</span>
<span class="token attr-name">spring.redis.host</span><span class="token punctuation">=</span><span class="token attr-value">192.168.8.11</span>
<span class="token comment" spellcheck="true">#Redis服务器连接端口</span>
<span class="token attr-name">spring.redis.port</span><span class="token punctuation">=</span><span class="token attr-value">6379</span>
<span class="token comment" spellcheck="true">#连接池最大连接数（使用负值表示没有限制）</span>
<span class="token attr-name">spring.redis.pool.max-active</span><span class="token punctuation">=</span><span class="token attr-value">8</span>
<span class="token comment" spellcheck="true">#连接池最大阻塞等待时间（使用负值表示没有限制）</span>
<span class="token attr-name">spring.redis.pool.max-wait</span><span class="token punctuation">=</span><span class="token attr-value">-1</span>
<span class="token comment" spellcheck="true">#连接池中的最大空闲连接</span>
<span class="token attr-name">spring.redis.pool.max-idle</span><span class="token punctuation">=</span><span class="token attr-value">8</span>
<span class="token comment" spellcheck="true">#连接池中的最小空闲连接</span>
<span class="token attr-name">spring.redis.pool.min-idle</span><span class="token punctuation">=</span><span class="token attr-value">0</span>
<span class="token comment" spellcheck="true">#连接超时时间（毫秒）</span>
<span class="token attr-name">spring.redis.timeout</span><span class="token punctuation">=</span><span class="token attr-value">30000</span>
<span class="token attr-name">logging.pattern.console</span><span class="token punctuation">=</span><span class="token attr-value">%d&amp;#123;MM/dd HH:mm:ss.SSS&amp;#125; %clr(%-5level) ---  [%-15thread] %cyan(%-50logger&amp;#123;50&amp;#125;):%msg%n</span>
</code></pre>
<h2 id="其他功能"><a href="#其他功能" class="headerlink" title="其他功能"></a>其他功能</h2><h3 id="发布与订阅"><a href="#发布与订阅" class="headerlink" title="发布与订阅"></a>发布与订阅</h3><p>先在一个终端上订阅channel</p>
<p>SUBSCRIBE channel</p>
<p>然后再开两个别的终端连上去，其中一个也订阅，就有两个订阅了</p>
<p>第三个就是发布者</p>
<p><img src="/2022/04/25/redis-bi-ji/image-20220421193244222.png" alt="image-20220421193244222"></p>
<p>终端1和终端2的页面是一样的</p>
<p>所以这就是发布订阅的功能，以后想搞聊天，博客等等可以使用一下</p>
<h3 id="慢查询"><a href="#慢查询" class="headerlink" title="慢查询"></a>慢查询</h3><p>慢查询日志帮助开发和运维人员定位系统存在的慢操作</p>
<p>慢查询就是工作的时候某一条命令，它的执行效率特别差的时候可以给他找出来优化一下</p>
<p>开发和运维都会用到，工作中解决问题</p>
<h5 id="什么是慢查询"><a href="#什么是慢查询" class="headerlink" title="什么是慢查询"></a>什么是慢查询</h5><p>慢查询，顾名思义就是比较慢的查询，但是究竟是哪里慢呢？</p>
<h5 id="Redis命令执行的整个过程"><a href="#Redis命令执行的整个过程" class="headerlink" title="Redis命令执行的整个过程"></a>Redis命令执行的整个过程</h5><p><img src="/2022/04/25/redis-bi-ji/image-20220421213049982.png" alt="image-20220421213049982"></p>
<p>两点说明： 1. 慢查询发生在第3阶段 2. 客户端超时不一定慢查询，但慢查询是客户端超时的一个可能因素 3. 慢查询日志是存放在Redis内存列表中。</p>
<h5 id="什么是慢查询日志"><a href="#什么是慢查询日志" class="headerlink" title="什么是慢查询日志"></a>什么是慢查询日志</h5><p>慢查询日志是Redis服务端在命令执行前后计算每条命令的执行时长，当超过某个阈值是记录下来的日 志。日志中记录了慢查询发生的时间，还有执行时长、具体什么命令等信息，它可以用来帮助开发和运 维人员定位系统中存在的慢查询。</p>
<h5 id="何获取慢查询日志"><a href="#何获取慢查询日志" class="headerlink" title="何获取慢查询日志"></a>何获取慢查询日志</h5><p>可以使用 slowlog get 命令获取慢查询日志，在 slowlog get 后面还可以加一个数字，用于指定获取 慢查询日志的条数，比如，获取3条慢查询日志： SLOWLOG get 3</p>
<h5 id="获取慢查询日志的长度"><a href="#获取慢查询日志的长度" class="headerlink" title="获取慢查询日志的长度"></a>获取慢查询日志的长度</h5><p>可以使用 slowlog len 命令获取慢查询日志的长度。</p>
<h5 id="怎么配置慢查询的参数"><a href="#怎么配置慢查询的参数" class="headerlink" title="怎么配置慢查询的参数"></a>怎么配置慢查询的参数</h5><ul>
<li>命令执行时长的指定阈值 slowlog-log-slower-than。</li>
</ul>
<p>​        slowlog-log-slower-than的作用是指定命令执行时长的阈值，执行命令的时长超过这个阈值时就会被记 录下来。</p>
<ul>
<li>存放慢查询日志的条数 slowlog-max-len。</li>
</ul>
<p>​         slowlog-max-len的作用是指定慢查询日志最多存储的条数。实际上，Redis使用了一个列表存放慢查询 日志，slowlog-max-len就是这个列表的最大长度。</p>
<h4 id="如何进行配置"><a href="#如何进行配置" class="headerlink" title="如何进行配置"></a>如何进行配置</h4><h5 id="查看慢日志配置"><a href="#查看慢日志配置" class="headerlink" title="查看慢日志配置"></a>查看慢日志配置</h5><p>客户端redis-cli连接上去之后config get slow*</p>
<pre class=" language-bash"><code class="language-bash">127.0.0.1:6379<span class="token operator">></span> config get slow*
1<span class="token punctuation">)</span> <span class="token string">"slowlog-max-len"</span>
2<span class="token punctuation">)</span> <span class="token string">"128"</span>
3<span class="token punctuation">)</span> <span class="token string">"slowlog-log-slower-than"</span>
4<span class="token punctuation">)</span> <span class="token string">"10000"</span>

10000阈值，单位微秒，此处为10毫秒，128慢日志记录保存数量的阈值，此处保存128条。
</code></pre>
<h5 id="修改Redis配置文件"><a href="#修改Redis配置文件" class="headerlink" title="修改Redis配置文件"></a>修改Redis配置文件</h5><p>比如，把slowlog-log-slower-than设置为1000，slowlog-max-len设置为1200：</p>
<pre class=" language-none"><code class="language-none">slowlog-log-slower-than 1000
slowlog-max-len 1200
</code></pre>
<h5 id="使用-config-set-命令动态修改。"><a href="#使用-config-set-命令动态修改。" class="headerlink" title="使用 config set 命令动态修改。"></a>使用 config set 命令动态修改。</h5><p>比如，还是把slowlog-log-slower-than设置为1000，slowlog-max-len设置为1200：</p>
<pre class=" language-bash"><code class="language-bash"><span class="token operator">></span> config <span class="token keyword">set</span> slowlog-log-slower-than 1000
OK
<span class="token operator">></span> config <span class="token keyword">set</span> slowlog-max-len 1200
OK
<span class="token operator">></span> config rewrite
OK
</code></pre>
<h4 id="实践建议"><a href="#实践建议" class="headerlink" title="实践建议"></a>实践建议</h4><p><strong>slowlog-max-len配置建议</strong></p>
<ul>
<li><p>线上建议调大慢查询列表，记录慢查询时Redis会对长命令做截断操作，并不会占用大量内存。 </p>
</li>
<li><p>增大慢查询列表可以减缓慢查询被剔除的可能，例如线上可设置为1000以上。</p>
</li>
</ul>
<p><strong>slowlog-log-slower-than配置建议</strong></p>
<ul>
<li><p>默认值超过10毫秒判定为慢查询，需要根据Redis并发量调整该值。 </p>
</li>
<li><p>由于Redis采用单线程响应命令，对于高流量的场景，如果命令执行时间在1毫秒以上，那么Redis 最多可支撑OPS不到1000。因此对于高OPS场景的Redis建议设置为1毫秒。</p>
</li>
</ul>
<h3 id="流水线popelines"><a href="#流水线popelines" class="headerlink" title="流水线popelines"></a>流水线popelines</h3><p>回去redisdemo项目</p>
<p>减少网络时间开销</p>
<p>回去之前的redisdemo项目测试</p>
<h5 id="1次网络命令通信模型"><a href="#1次网络命令通信模型" class="headerlink" title="1次网络命令通信模型"></a>1次网络命令通信模型</h5><p><img src="/2022/04/25/redis-bi-ji/image-20220421212701439.png" alt="image-20220421212701439"></p>
<p>经历了1次时间 &#x3D; 1次网络时间 + 1次命令时间。</p>
<h5 id="批量网络命令通信模型"><a href="#批量网络命令通信模型" class="headerlink" title="批量网络命令通信模型"></a>批量网络命令通信模型</h5><p><img src="/2022/04/25/redis-bi-ji/image-20220421212717693.png" alt="image-20220421212717693"></p>
<p>经历了 n次时间 &#x3D; n次网络时间 + n次命令时间</p>
<h5 id="什么是流水线？"><a href="#什么是流水线？" class="headerlink" title="什么是流水线？"></a>什么是流水线？</h5><p><img src="/2022/04/25/redis-bi-ji/image-20220421212733784.png" alt="image-20220421212733784"></p>
<p>经历了 1次pipeline(n条命令) &#x3D; 1次网络时间 + n次命令时间，这大大减少了网络时间的开销，这就是流 水线。</p>
<p>案例展示 从北京到上海的一条命令的生命周期有多长？</p>
<p><img src="/2022/04/25/redis-bi-ji/image-20220421212808232.png" alt="image-20220421212808232"></p>
<p>执行一条命令在redis端可能需要几百微秒，而在网络光纤中传输只花费了13毫秒。</p>
<p>注意： 在执行批量操作而没有使用pipeline功能，会将大量的时间耗费在每一次网络传输的过程上；而使 用pipeline后，只需要经过一次网络传输，然后批量在redis端进行命令操作。这会大大提高了效 率。</p>
<p>实现：先引入jedis依赖包</p>
<pre class=" language-JAVA"><code class="language-JAVA">/**
 * 没有pipeline测试
 */
@Test
public void pipelineTest()&#123;
    //开始时间
    long startTime = System.currentTimeMillis();
    //添加元素
    for (int i = 0; i < 10000; i++) &#123;
        jedis.hset("hashkey"+i,"field"+i,"value"+i);
    &#125;
    //结束时间
    long endTime = System.currentTimeMillis();
    System.out.println(endTime-startTime);
&#125;

/**
 * pipeline测试
 */
@Test
public void pipelineTest2()&#123;
    //开始时间
    long startTime = System.currentTimeMillis();
    //添加元素
    for (int i = 0; i < 100; i++) &#123;
        Pipeline pipeline = jedis.pipelined();
        for (int j = i*100; j < (i+1)*100; j++) &#123;
            pipeline.hset("hashkey"+j,"field"+j,"value"+j);
        &#125;
        pipeline.syncAndReturnAll();
    &#125;
    //结束时间
    long endTime = System.currentTimeMillis();
    System.out.println(endTime-startTime);
&#125;
</code></pre>
<p>没有pipeline的——–2765毫秒</p>
<p><img src="/2022/04/25/redis-bi-ji/image-20220421204624848.png" alt="image-20220421204624848"></p>
<p>pipeline测试—-79毫秒</p>
<p><img src="/2022/04/25/redis-bi-ji/image-20220421205148053.png" alt="image-20220421205148053"></p>
<p>所以以后批量添加的时候就要使用pipeline</p>
<h3 id="Redis数据安全"><a href="#Redis数据安全" class="headerlink" title="Redis数据安全"></a>Redis数据安全</h3><p>​        由于Redis的数据都存放在内存中，如果没有配置持久化，Redis重启后数据就全丢失了，于是需要开启 Redis的持久化功能，将数据保存到磁盘上，当Redis重启后，可以从磁盘中恢复数据。</p>
<h4 id="持久化机制概述"><a href="#持久化机制概述" class="headerlink" title="持久化机制概述"></a>持久化机制概述</h4><p>​        对于Redis而言，持久化机制是指把内存中的数据存为硬盘文件， 这样当Redis重启或服务器故障时能根 据持久化后的硬盘文件恢复数 据。</p>
<h4 id="持久化机制的意义"><a href="#持久化机制的意义" class="headerlink" title="持久化机制的意义"></a>持久化机制的意义</h4><p>redis持久化的意义，在于<strong>故障恢复</strong>。比如部署了一个redis，作为cache缓存，同时也可以保存一些比较 重要的数据。</p>
<p><img src="/2022/04/25/redis-bi-ji/image-20220421212535122.png" alt="image-20220421212535122"></p>
<p>也可以定期把磁盘里的文件备份到云存储服务上去，就可以保证数据永久不丢失</p>
<h5 id="Redis提供了两个不同形式的持久化方式"><a href="#Redis提供了两个不同形式的持久化方式" class="headerlink" title="Redis提供了两个不同形式的持久化方式"></a>Redis提供了两个不同形式的持久化方式</h5><p>RDB(Redis DataBase) ——-其实就是把数据以快照的形式保存在磁盘上</p>
<p>AOF(Append Only File)———-可以理解为追加文件的方式</p>
<h4 id="持久化机制实战"><a href="#持久化机制实战" class="headerlink" title="持久化机制实战"></a>持久化机制实战</h4><h5 id="RDB是什么"><a href="#RDB是什么" class="headerlink" title="RDB是什么"></a>RDB是什么</h5><p>​        在指定的时间间隔内将内存的数据集快照写入磁盘，也就是行话讲的快照，它恢复时是将快照文件直接 读到内存里。</p>
<h5 id="配置dump-rdb文件"><a href="#配置dump-rdb文件" class="headerlink" title="配置dump.rdb文件"></a>配置dump.rdb文件</h5><p>400多行就是生成文件的名字，:set nu 就可设置行号</p>
<p>改一下生成文件的路径<br>rdb文件的保存位置，也可以修改。默认在Redis启动时命令行所在的目录下。</p>
<p><img src="/2022/04/25/redis-bi-ji/image-20220422095200309.png" alt="image-20220422095200309"></p>
<h5 id="触发机制-主要三种方式"><a href="#触发机制-主要三种方式" class="headerlink" title="触发机制-主要三种方式"></a>触发机制-主要三种方式</h5><h6 id="RDB配置"><a href="#RDB配置" class="headerlink" title="RDB配置"></a>RDB配置</h6><p>快照默认配置： </p>
<ul>
<li>save 3600 1：表示3600秒内（一小时）如果至少有1个key的值变化，则保存。 </li>
<li>save 300 100：表示300秒内（五分钟）如果至少有100个 key 的值变化，则保存。 </li>
<li>save 60 10000：表示60秒内如果至少有 10000个key的值变化，则保存。</li>
</ul>
<h6 id="配置新的保存规则"><a href="#配置新的保存规则" class="headerlink" title="配置新的保存规则"></a>配置新的保存规则</h6><p>给redis.conf添加新的快照策略，30秒内如果有5次key的变化，则触发快照。配置修改后，需要重启 Redis服务。</p>
<p>加一个save 5 1做演示  5s内有一个key改变就出发</p>
<h5 id="flushall"><a href="#flushall" class="headerlink" title="flushall"></a>flushall</h5><p>执行flushall命令，也会触发rdb规则。</p>
<p>加两个数据触发就可以看见</p>
<p><img src="/2022/04/25/redis-bi-ji/image-20220422100616324.png" alt="image-20220422100616324"></p>
<p>然后加入redis出问题，那启动的时候就会自动的把这个文件加载到内存中</p>
<h5 id="save与bgsave"><a href="#save与bgsave" class="headerlink" title="save与bgsave"></a>save与bgsave</h5><p>手动触发Redis进行RDB持久化的命令有两种：</p>
<ol>
<li>save 该命令会阻塞当前Redis服务器，执行save命令期间，Redis不能处理其他命令，直到RDB过程完成 为止，不建议使用。</li>
<li>bgsave 执行该命令时，Redis会在后台异步进行快照操作，快照同时还可以响应客户端请求。</li>
</ol>
<h5 id="高级配置"><a href="#高级配置" class="headerlink" title="高级配置"></a>高级配置</h5><h6 id="stop-writes-on-bgsave-error"><a href="#stop-writes-on-bgsave-error" class="headerlink" title="stop-writes-on-bgsave-error"></a>stop-writes-on-bgsave-error</h6><p>默认值是yes。当Redis无法写入磁盘的话，直接关闭Redis的写操作。</p>
<h6 id="rdbcompression"><a href="#rdbcompression" class="headerlink" title="rdbcompression"></a>rdbcompression</h6><p>​        默认值是yes。对于存储到磁盘中的快照，可以设置是否进行压缩存储。如果是的话，redis会采用LZF算 法进行压缩。如果你不想消耗CPU来进行压缩的话，可以设置为关闭此功能，但是存储在磁盘上的快照 会比较大。</p>
<h6 id="rdbchecksum"><a href="#rdbchecksum" class="headerlink" title="rdbchecksum"></a>rdbchecksum</h6><p>默认值是yes。在存储快照后，我们还可以让redis使用CRC64算法来进行数据校验，但是这样做会增加 大约10%的性能消耗，如果希望获取到最大的性能提升，可以关闭此功能。</p>
<h6 id="恢复数据"><a href="#恢复数据" class="headerlink" title="恢复数据"></a>恢复数据</h6><p>只需要将rdb文件放在Redis的启动目录，Redis启动时会自动加载dump.rdb并恢复数据。</p>
<p>kill掉都可以恢复，只要有这个文件就会默认帮我们去加载</p>
<p><img src="/2022/04/25/redis-bi-ji/image-20220422101157274.png" alt="image-20220422101157274"></p>
<h5 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h5><ul>
<li>适合大规模的数据恢复 </li>
<li>对数据完整性和一致性要求不高更适合使用 </li>
<li>节省磁盘空间 </li>
<li>恢复速度快</li>
</ul>
<h5 id="劣势"><a href="#劣势" class="headerlink" title="劣势"></a>劣势</h5><p>在备份周期在一定间隔时间做一次备份，所以如果Redis意外down掉的话，就会丢失最后一次快照后的所有修改。</p>
<h4 id="AOF持久化机制"><a href="#AOF持久化机制" class="headerlink" title="AOF持久化机制"></a>AOF持久化机制</h4><p>AOF持久化机制通俗的理解就是日志记录</p>
<p><img src="/2022/04/25/redis-bi-ji/image-20220425190344559.png" alt="image-20220425190344559"></p>
<h5 id="AOF是什么"><a href="#AOF是什么" class="headerlink" title="AOF是什么"></a>AOF是什么</h5><p>以日志的形式来记录每个写操作，将Redis执行过的所有写指令记录下来。</p>
<p>默认不开启AOF，改一下开启 改完要重启redis服务<br>可以在redis.conf中配置文件名称，默认为appendonly.aof。</p>
<p><img src="/2022/04/25/redis-bi-ji/image-20220422110902027.png" alt="image-20220422110902027"></p>
<h6 id="注意：-2"><a href="#注意：-2" class="headerlink" title="注意："></a>注意：</h6><p>AOF文件的保存路径，同RDB的路径一致，如果AOF和RDB同时启动，<strong>Redis默认读取AOF的数据。</strong></p>
<h5 id="AOF同步频率设置"><a href="#AOF同步频率设置" class="headerlink" title="AOF同步频率设置"></a>AOF同步频率设置</h5><p><img src="/2022/04/25/redis-bi-ji/image-20220425190527044.png" alt="image-20220425190527044"></p>
<h6 id="参数："><a href="#参数：" class="headerlink" title="参数："></a>参数：</h6><p>1.appendfsync always </p>
<p>​    始终同步，每次Redis的写入都会立刻记入日志，性能较差但数据完整性比较好。 </p>
<p>2.appendfsync everysec </p>
<p>​    每秒同步，每秒记入日志一次，如果宕机，本秒的数据可能丢失。 </p>
<p>3.appendfsync no </p>
<p>​    redis不主动进行同步，把同步时机交给操作系统。</p>
<h5 id="优势-1"><a href="#优势-1" class="headerlink" title="优势"></a>优势</h5><ul>
<li>备份机制更稳健，丢失数据概率更低。 </li>
<li>可读的日志文本，通过操作AOF稳健，可以处理误操作。</li>
</ul>
<p>劣势 </p>
<ul>
<li>比起RDB占用更多的磁盘空间。 </li>
<li>恢复备份速度要慢。 </li>
<li>每次读写都同步的话，有一定的性能压力。</li>
</ul>
<p>保存的都是一堆命令</p>
<p><img src="/2022/04/25/redis-bi-ji/image-20220422111132449.png" alt="image-20220422111132449"></p>
<p>然后手动清除一下，再去aof文件中的最后一行把这个手动删除的命令删掉保存退出</p>
<p>然后你再启动的时候就会把aof文件里的命令再跑一遍</p>
<p><strong>基本上都是选每秒同步</strong></p>
<h4 id="如何选择持久化机制"><a href="#如何选择持久化机制" class="headerlink" title="如何选择持久化机制"></a>如何选择持久化机制</h4><h6 id="不要仅仅使用RDB"><a href="#不要仅仅使用RDB" class="headerlink" title="不要仅仅使用RDB"></a>不要仅仅使用RDB</h6><p>​        RDB数据快照文件，都是每隔5分钟，或者更长时间生成一次，这个时候就得接受一旦redis进程宕机， 那么会丢失最近5分钟的数据。</p>
<h6 id="也不要仅仅使用AOF"><a href="#也不要仅仅使用AOF" class="headerlink" title="也不要仅仅使用AOF"></a>也不要仅仅使用AOF</h6><p>1.你通过AOF做冷备，没有RDB做冷备，来的恢复速度更快。 </p>
<p>2.RDB每次简单粗暴生成数据快照，更加健壮，可以避免AOF这种复杂的备份和恢复机制的bug。</p>
<p>冷备份，比如每天晚上十二点保存一个RDB的快照到云平台上</p>
<p>想恢复就直接拷去redis就行</p>
<h5 id="综合使用AOF和RDB两种持久化机制"><a href="#综合使用AOF和RDB两种持久化机制" class="headerlink" title="综合使用AOF和RDB两种持久化机制"></a>综合使用AOF和RDB两种持久化机制</h5><p>​        用AOF来保证数据不丢失，作为数据恢复的第一选择，用RDB来做不同程度的冷备，在AOF文件都丢失或损坏不可用的时候，还可以使用RDB来进行快速的数据恢复。</p>
<h3 id="Redis事务"><a href="#Redis事务" class="headerlink" title="Redis事务"></a>Redis事务</h3><p>数据库事务的四大特性 </p>
<ul>
<li>A：Atomic，原子性，将所有SQL作为原子工作单元执行，要么全部执行，要么全部不执行； </li>
<li>C：Consistent，一致性，事务完成后，所有数据的状态都是一致的，即A账户只要减去了100，B 账户则必定加上了100； </li>
<li>I：Isolation，隔离性，如果有多个事务并发执行，每个事务作出的修改必须与其他事务隔离； </li>
<li>D：Duration，持久性，即事务完成后，对数据库数据的修改被持久化存储。</li>
</ul>
<h5 id="Redis事务-1"><a href="#Redis事务-1" class="headerlink" title="Redis事务"></a>Redis事务</h5><p>​        Redis事务是一组命令的集合，一个事务中的所有命令都将被序列化，按照一次性、顺序性、排他性的执 行一系列的命令</p>
<h5 id="Redis事务三大特性"><a href="#Redis事务三大特性" class="headerlink" title="Redis事务三大特性"></a>Redis事务三大特性</h5><ol>
<li>单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其 他客户端发送来的命令请求所打断； </li>
<li>没有隔离级别的概念：队列中的命令没有提交之前都不会实际的被执行，因为事务提交前任何指令 都不会被实际执行，也就不存在”事务内的查询要看到事务里的更新，在事务外查询不能看到”。 </li>
<li>不保证原子性：redis同一个事务中如果有一条命令执行失败，其后的命令仍然会被执行，没有回滚；</li>
</ol>
<h5 id="Redis事务执行的三个阶段"><a href="#Redis事务执行的三个阶段" class="headerlink" title="Redis事务执行的三个阶段"></a>Redis事务执行的三个阶段</h5><ul>
<li>开启：以 MULTI 开始一个事务； </li>
<li>入队：将多个命令入队到事务中，接到这些命令并不会立即执行，而是放到等待执行的事务队列里面； </li>
<li>执行：由 EXEC 命令触发事务；</li>
</ul>
<h4 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h4><h5 id="Multi、Exec、discard"><a href="#Multi、Exec、discard" class="headerlink" title="Multi、Exec、discard"></a>Multi、Exec、discard</h5><p>​        事务从输入Multi命令开始，输入的命令都会依次压入命令缓冲队列中，并不会执行，直到输入Exec后， Redis会将之前的命令缓冲队列中的命令依次执行。组队过程中，可以通过discard来放弃组队。</p>
<h5 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h5><p>正常事务提交</p>
<p><strong><img src="/2022/04/25/redis-bi-ji/image-20220424080022115.png" alt="image-20220424080022115"></strong></p>
<p>取消</p>
<p><img src="/2022/04/25/redis-bi-ji/image-20220424080124561.png" alt="image-20220424080124561"></p>
<p>事务里面出现<strong>语法错误</strong>，就会全部失败，就是一种连带责任</p>
<p>还有一种就是冤有头债有主</p>
<p><img src="/2022/04/25/redis-bi-ji/image-20220424080509486.png" alt="image-20220424080509486"></p>
<h2 id="Redis集群"><a href="#Redis集群" class="headerlink" title="Redis集群"></a>Redis集群</h2><p><img src="/2022/04/25/redis-bi-ji/image-20220425191427072.png" alt="image-20220425191427072"></p>
<h4 id="什么是主从复制"><a href="#什么是主从复制" class="headerlink" title="什么是主从复制"></a>什么是主从复制</h4><p>主从复制，是指将一台Redis服务器的数据，复制到其他的Redis服务器。前者称为主节点(master)，后 者称为从节点(slave),数据的复制是单向的，只能由主节点到从节点。</p>
<p><img src="/2022/04/25/redis-bi-ji/image-20220425191658932.png" alt="image-20220425191658932"></p>
<p>写操作从主机点，从节点处理读操作</p>
<h4 id="主从复制的作用"><a href="#主从复制的作用" class="headerlink" title="主从复制的作用"></a>主从复制的作用</h4><p>1.<strong>数据冗余：</strong>主从复制实现了数据的热备份，是持久化之外的一种数据冗余方式。 </p>
<p>2.<strong>故障恢复：</strong>当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复；实际上是一种服 务的冗余。 </p>
<p>3.<strong>负载均衡：</strong>在主从复制的基础上，配合读写分离，可以由主节点提供写服务，由从节点提供读服务 （即写Redis数据时应用连接主节点，读Redis数据时应用连接从节点），分担服务器负载；尤其是 在写少读多的场景下，通过多个从节点分担读负载，可以大大提高Redis服务器的并发量。</p>
<p>4.<strong>高可用基石：</strong>除了上述作用以外，主从复制还是哨兵和集群能够实施的基础，因此说主从复制是 Redis高可用的基础。</p>
<h4 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h4><p>学习就可以去一台机器搭建三个redis</p>
<p>就是新加三个配置文件，并针对端口做不同修改</p>
<p>redis6379.conf  redis6380.conf  6381.conf</p>
<p>就对应改下面三个地方</p>
<p><img src="/2022/04/25/redis-bi-ji/image-20220425192020449.png" alt="image-20220425192020449"></p>
<p>启动三台</p>
<pre class=" language-none"><code class="language-none">./redis-server ../redis6379.conf
./redis-server ../redis6380.conf
./redis-server ../redis6381.conf
</code></pre>
<p>查看是否搭建完成</p>
<p><strong><img src="/2022/04/25/redis-bi-ji/image-20220424084531105.png" alt="image-20220424084531105"></strong></p>
<p>然后再开几个终端连接上去</p>
<p><img src="/2022/04/25/redis-bi-ji/image-20220424084757643.png" alt="image-20220424084757643"></p>
<p>但是还没有去配置认老大</p>
<p>就是在小弟这里配置</p>
<h5 id="配从库不配主库"><a href="#配从库不配主库" class="headerlink" title="配从库不配主库"></a>配从库不配主库</h5><p><img src="/2022/04/25/redis-bi-ji/image-20220424084928252.png" alt="image-20220424084928252"></p>
<p>然后三台机器都可以看一下</p>
<p>主节点</p>
<p><img src="/2022/04/25/redis-bi-ji/image-20220424085423087.png" alt="image-20220424085423087"></p>
<p>从节点</p>
<p><img src="/2022/04/25/redis-bi-ji/image-20220424085519137.png" alt="image-20220424085519137"><img src="/2022/04/25/redis-bi-ji/image-20220424085538862.png" alt="image-20220424085538862"></p>
<p>然后你可以去试一试他们的数据是否同步    然后你会发现数据就是同步的</p>
<p>试一试从节点能不能保存数据（不能），只能读操作</p>
<p><img src="/2022/04/25/redis-bi-ji/image-20220424085749352.png" alt="image-20220424085749352"></p>
<h4 id="主从复制原理剖析"><a href="#主从复制原理剖析" class="headerlink" title="主从复制原理剖析"></a>主从复制原理剖析</h4><p>主从复制可以分为3个阶段六个过程</p>
<ul>
<li>连接建立阶段</li>
<li>数据同步阶段</li>
<li>命令传播阶段</li>
</ul>
<p>复制过程大致分为6个过程</p>
<p><img src="/2022/04/25/redis-bi-ji/image-20220425193232590.png" alt="image-20220425193232590"></p>
<p>1、保存主节点（master）信息。</p>
<p>2、从节点（slave）内部通过每秒运行的定时任务维护复制相关逻辑，当定时任务发现存在新的主 节点后，会尝试与该节点建立网络连接</p>
<p><img src="/2022/04/25/redis-bi-ji/image-20220425193317658.png" alt="image-20220425193317658"></p>
<p>3、从节点与主节点建立网络连接 </p>
<p>从节点会建立一个 socket 套接字，从节点建立了一个端口为51234的套接字，专门用于接受主节点发送 的复制命令。</p>
<p><img src="/2022/04/25/redis-bi-ji/image-20220425193335769.png" alt="image-20220425193335769"></p>
<p>4、发送ping命令 </p>
<p>连接建立成功后从节点发送 ping 请求进行首次通信</p>
<p><img src="/2022/04/25/redis-bi-ji/image-20220425193400062.png" alt="image-20220425193400062"></p>
<h6 id="作用："><a href="#作用：" class="headerlink" title="作用："></a>作用：</h6><ul>
<li>检测主从之间网络套接字是否可用。 </li>
<li>检测主节点当前是否可以接受命令 。</li>
</ul>
<p>4、权限验证。</p>
<p>​        如果主节点设置了 requirepass 参数，则需要密码验证，从节点必须配置 masterauth 参数保证与主节 点相同的密码才能通过验证；如果验证失败复制将终止，从节点重新发起复制流程。</p>
<p>5、同步数据集。 </p>
<p>​        主从复制连接正常通信后，对于首次建立复制的场景，主节点会把持有的数据全部发送给从节点，这部 分操作是耗时最长的步骤。</p>
<p>主节点那900多行有一个requirepass（注释掉的）  </p>
<p>如果你把他放开之后，就代表reids设置了密码  从节点连接的时候就要密码，不然到不了第五步的同步数据</p>
<h5 id="主从同步策略"><a href="#主从同步策略" class="headerlink" title="主从同步策略"></a>主从同步策略</h5><p>​        主从刚刚连接的时候，进行全量同步；全同步结束后，进行增量同步。当然，如果有需要，slave 在任何时候都可以发起全量同步。redis 策略是，无论如何，首先会尝试进行增量同步，如不成功，要求从机进行全量同步。</p>
<pre class=" language-none"><code class="language-none">$3 \r \n
set \r \n
$4 \r \n
name \r \n
</code></pre>
<p><img src="/2022/04/25/redis-bi-ji/image-20220425193634389.png" alt="image-20220425193634389"></p>
<p><img src="/2022/04/25/redis-bi-ji/image-20220425193756367.png" alt="image-20220425193756367"></p>
<p>偏移量相等说明master的数据就全部同步过去了。</p>
<p>6、命令持续复制。 </p>
<p>​        当主节点把当前的数据同步给从节点后，便完成了复制的建立流程。接下来主节点会持续地把写命令发 送给从节点，保证主从数据一致性。</p>
<h3 id="哨兵监控"><a href="#哨兵监控" class="headerlink" title="哨兵监控"></a>哨兵监控</h3><h4 id="Redis主从复制缺点"><a href="#Redis主从复制缺点" class="headerlink" title="Redis主从复制缺点"></a>Redis主从复制缺点</h4><p>当主机 Master 宕机以后，我们需要人工解决切换。</p>
<p><img src="/2022/04/25/redis-bi-ji/image-20220425193848246.png" alt="image-20220425193848246"></p>
<p>暴漏问题： 一旦主节点宕机，写服务无法使用，就需要手动去切换，重新选取主节点，手动设置主从关系。</p>
<h5 id="主从切换技术"><a href="#主从切换技术" class="headerlink" title="主从切换技术"></a>主从切换技术</h5><p>​        当主服务器宕机后，需要手动把一台从服务器切换为主服务器，这就需要人工干预，费事费力，还会造 成一段时间内服务不可用。这不是一种推荐的方式，更多时候，我们优先考虑<strong>哨兵模式。</strong></p>
<h5 id="哨兵概述"><a href="#哨兵概述" class="headerlink" title="哨兵概述"></a>哨兵概述</h5><p>​        哨兵模式是一种特殊的模式，首先Redis提供了哨兵的命令，哨兵是一个独立的进程，作为进程，它会独 立运行。其原理是哨兵通过发送命令，等待Redis服务器响应，从而监控运行的多个Redis实例。</p>
<h5 id="哨兵作用"><a href="#哨兵作用" class="headerlink" title="哨兵作用"></a>哨兵作用</h5><ul>
<li>集群监控：负责监控redis master和slave进程是否正常工作 </li>
<li>消息通知：如果某个redis实例有故障，那么哨兵负责发送消息作为报警通知给管理员 </li>
<li>故障转移：如果master node挂掉了，会自动转移到slave node上</li>
<li>配置中心：如果故障转移发生了，通知client客户端新的master地址</li>
</ul>
<h4 id="哨兵监控环境搭建"><a href="#哨兵监控环境搭建" class="headerlink" title="哨兵监控环境搭建"></a>哨兵监控环境搭建</h4><p>参数就是3给2，5给3 7给4，懂我意思吧</p>
<p>新建sentinel-26379.conf文件</p>
<pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true">#端口</span>
port 26379
<span class="token comment" spellcheck="true">#守护进程运行</span>
daemonize <span class="token function">yes</span>
<span class="token comment" spellcheck="true">#日志文件</span>
logfile <span class="token string">"26379.log"</span>
sentinel monitor mymaster 127.0.0.1 6379 2
</code></pre>
<h6 id="参数：-1"><a href="#参数：-1" class="headerlink" title="参数："></a>参数：</h6><p>sentinel monitor mymaster 192.168.92.128 6379 2 配置的含义是：该哨兵节点监控 192.168.92.128:6379这个主节点，该主节点的名称是mymaster，最后的2的含义与主节点的故障 判定有关：至少需要2个哨兵节点同意，才能判定主节点故障并进行故障转移。</p>
<p>然后写好一个sentinel配置文件之后，复制俩份，复制的两份都只改端口和日志文件。</p>
<p><img src="/2022/04/25/redis-bi-ji/image-20220424093534583.png" alt="image-20220424093534583"></p>
<p>学习嘛，也是一台机器搭建三个哨兵，生产环境就是一台机器放一个哨兵</p>
<p>启动方式，两种</p>
<p>记一种就算了，第一种</p>
<pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 第一种</span>
redis-sentinel 配置文件名字

<span class="token comment" spellcheck="true">#第二种</span>
redis-server 配置文件名字--sentinel
</code></pre>
<p>连接进去哨兵</p>
<p>查看哨兵节点状态</p>
<p><img src="/2022/04/25/redis-bi-ji/image-20220424094229091.png" alt="image-20220424094229091"></p>
<h4 id="哨兵工作原理"><a href="#哨兵工作原理" class="headerlink" title="哨兵工作原理"></a>哨兵工作原理</h4><h5 id="监控阶段"><a href="#监控阶段" class="headerlink" title="监控阶段"></a>监控阶段</h5><p><img src="/2022/04/25/redis-bi-ji/image-20220425195154281.png" alt="image-20220425195154281"></p>
<p>注意： </p>
<ul>
<li>sentinel(哨兵1)—–&gt;向master(主)和slave(从)发起info，拿到全信息。 </li>
<li>sentinel(哨兵2)—–&gt;向master(主)发起info，就知道已经存在的sentinel(哨兵1)的信息，并且 连接slave(从)。 </li>
<li>sentinel(哨兵2)—–&gt;向sentinel(哨兵1)发起subscribe(订阅)。</li>
</ul>
<h5 id="通知阶段"><a href="#通知阶段" class="headerlink" title="通知阶段"></a>通知阶段</h5><p>sentinel不断的向master和slave发起通知，收集信息。</p>
<h5 id="故障转移阶段"><a href="#故障转移阶段" class="headerlink" title="故障转移阶段"></a>故障转移阶段</h5><p>​        通知阶段sentinel发送的通知没得到master的回应，就会把master标记为SRI_S_DOWN,并且把master 的状态发给各个sentinel，其他sentinel听到master挂了，说我不信，我也去看看，并把结果共享给各 个sentinel，当有一半的sentinel都认为master挂了的时候，就会把master标记为SRI_0_DOWN</p>
<p>问题来了： 这时就要把master给换掉了，到底谁当Master呢。</p>
<p>自己最先接到哪个sentinel的竞选通知就会把票投给它。</p>
<p>剔除一些情况： 1. 不在线的 2. 响应慢的 3. 与原来master断开时间久的 4. 优先级原则</p>
<h4 id="故障转移"><a href="#故障转移" class="headerlink" title="故障转移"></a>故障转移</h4><h4 id="演示故障转移"><a href="#演示故障转移" class="headerlink" title="演示故障转移"></a>演示故障转移</h4><p>直接kill掉主节点</p>
<p>kill完之后在哨兵节点种查看一下</p>
<p><img src="/2022/04/25/redis-bi-ji/image-20220424102845205.png" alt="image-20220424102845205"></p>
<p>主节点不是6379么，然后现在变成6380，自动切换，所以这就是哨兵故障转移过程</p>
<p>注意：这里还是比较快切换过来的，但是一般来说会需要一段时间</p>
<p>然后我们重启一下6379看看</p>
<p><img src="/2022/04/25/redis-bi-ji/image-20220424103503039.png" alt="image-20220424103503039"></p>
<p>故障转移，哨兵和所有的配置文件都会被改写</p>
<p>比如看一下，这块就是新加的内容</p>
<p><img src="/2022/04/25/redis-bi-ji/image-20220424103744511.png" alt="image-20220424103744511"></p>
<h5 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h5><ul>
<li>哨兵系统中的主从节点，与普通的主从节点并没有什么区别，故障发现和转移是由哨兵来控制和完 成的。 </li>
<li>哨兵节点本质上是redis节点。 </li>
<li>每个哨兵节点，只需要配置监控主节点，便可以自动发现其他的哨兵节点和从节点。 </li>
<li>在哨兵节点启动和故障转移阶段，各个节点的配置文件会被重写(config rewrite)。</li>
</ul>
<h3 id="Cluster模式概述"><a href="#Cluster模式概述" class="headerlink" title="Cluster模式概述"></a>Cluster模式概述</h3><p>redis集群是一个由多个主从节点群组成的分布式服务集群</p>
<p>Redis有三种集群模式 </p>
<p>主从模式 </p>
<p>Sentinel模式 </p>
<p>Cluster模式</p>
<h4 id="哨兵模式的缺点"><a href="#哨兵模式的缺点" class="headerlink" title="哨兵模式的缺点"></a>哨兵模式的缺点</h4><ul>
<li>当master挂掉的时候，sentinel 会选举出来一个 master，选举的时候是没有办法去访问 Redis的，会存在访问瞬断的情况； </li>
<li>哨兵模式，对外只有master节点可以写，slave节点只能用于读。尽管Redis单节点最多支持 10W的QPS，但是在电商大促的时候，写数据的压力全部在master上。</li>
<li>Redis的单节点内存不能设置过大，若数据过大在主从同步将会很慢；在节点启动的时候，时间特别长；</li>
</ul>
<p>最大缺点：哨兵选举期间，不能对外提供服务</p>
<p><img src="/2022/04/25/redis-bi-ji/image-20220425195649429.png" alt="image-20220425195649429"></p>
<h5 id="Redis集群的优点"><a href="#Redis集群的优点" class="headerlink" title="Redis集群的优点"></a>Redis集群的优点</h5><ul>
<li>Redis集群有多个master，可以减小访问瞬断问题的影响 </li>
<li>Redis集群有多个master，可以提供更高的并发量　 </li>
<li>Redis集群可以分片存储，这样就可以存储更多的数据</li>
</ul>
<h4 id="Cluster模式搭建"><a href="#Cluster模式搭建" class="headerlink" title="Cluster模式搭建"></a>Cluster模式搭建</h4><p>​        Redis的集群搭建最少需要3个master节点，我们这里搭建3个master，每个下面挂一个slave节点，总 共6个Redis节点；</p>
<p>​        直接复制虚拟机，docker复制过去三台redis机器，视频里是三台上传好jar包，然后xshell都连接上点一个发送到所有会话，然后进行编译安装</p>
<p>重启之后都出现一个问题，三步解决</p>
<p><img src="/2022/04/25/redis-bi-ji/image-20220424135120486.png" alt="image-20220424135120486"></p>
<p>搭建机器为Redis-1、2、3  自动分配，所以是8.17 18 19这三个ip</p>
<p>先使用发送键盘输入的所有会话</p>
<p>然后创建redis目录下创建一个redis-cluster目录</p>
<p>里面再创建8001、8002两个目录</p>
<p>配置文件分别拷贝进去一份</p>
<p>接着进行修改</p>
<p>先改端口6379改为8001，然后开启后台运行（daemonize yes）</p>
<p>然后</p>
<p><img src="/2022/04/25/redis-bi-ji/image-20220424140725656.png" alt="image-20220424140725656"></p>
<p>接着</p>
<p><img src="/2022/04/25/redis-bi-ji/image-20220424140818190.png" alt="image-20220424140818190"></p>
<p>改一下Xshell编码，加一个注释</p>
<p><img src="/2022/04/25/redis-bi-ji/image-20220424141144801.png" alt="image-20220424141144801"></p>
<p>启动集群模式</p>
<p><img src="/2022/04/25/redis-bi-ji/image-20220424141249738.png" alt="image-20220424141249738"></p>
<p><img src="/2022/04/25/redis-bi-ji/image-20220424141404202.png" alt="image-20220424141404202"></p>
<p>修改集群离线的超时时间</p>
<p><img src="/2022/04/25/redis-bi-ji/image-20220424141534159.png" alt="image-20220424141534159"></p>
<p><img src="/2022/04/25/redis-bi-ji/image-20220424141637020.png" alt="image-20220424141637020"></p>
<p>继续，关闭保护模式</p>
<p><img src="/2022/04/25/redis-bi-ji/image-20220424141721657.png" alt="image-20220424141721657"></p>
<p>开启AOF</p>
<p><img src="/2022/04/25/redis-bi-ji/image-20220424141752025.png" alt="image-20220424141752025"></p>
<p>要配密码自己配，我不搞</p>
<p>但是配了密码就要在下面加一个masterauth xxx</p>
<p>拷贝一份去8002，修改  g就是全局修改</p>
<p><img src="/2022/04/25/redis-bi-ji/image-20220424142748129.png" alt="image-20220424142748129"></p>
<p>这样所有配置文件就都弄好了，关闭一下防火墙（我是一直都关了的）</p>
<p>然后就可以开始启动服务了，这样就启动好了6台</p>
<p><img src="/2022/04/25/redis-bi-ji/image-20220424143103158.png" alt="image-20220424143103158"></p>
<p>看一下也没有问题</p>
<p><img src="/2022/04/25/redis-bi-ji/image-20220424143154967.png" alt="image-20220424143154967"></p>
<p>这样准备工作就完事了，就不用发送到所有会话了</p>
<p>如果配置了密码，就要</p>
<p><img src="/2022/04/25/redis-bi-ji/image-20220424143324043.png" alt="image-20220424143324043"></p>
<p>1的意思就是每一个master下面有一个slave</p>
<pre class=" language-none"><code class="language-none">./redis-cli --cluster create --cluster-replicas 1 192.168.8.17:8001 192.168.8.17:8002 192.168.8.18:8001 192.168.8.18:8002 192.168.8.19:8001 192.168.8.19:8002
</code></pre>
<p>然后回车输入yes，看见两个绿的就说明cluster模式就已经创建成功了</p>
<p><img src="/2022/04/25/redis-bi-ji/image-20220424143701248.png" alt="image-20220424143701248"></p>
<p>可以查看帮助</p>
<pre class=" language-none"><code class="language-none">./redis-cli --cluster help
</code></pre>
<p>然后可以通过add-node一直去水平无限拓展添加节点</p>
<p><img src="/2022/04/25/redis-bi-ji/image-20220424144014581.png" alt="image-20220424144014581"></p>
<p>还可以check查看集群状态</p>
<p>连进去看看，连接到某一个连接</p>
<p><img src="/2022/04/25/redis-bi-ji/image-20220424144124446.png" alt="image-20220424144124446"></p>
<p>-c：以集群方式连接</p>
<p>-h：ip地址是哪</p>
<p>-p：端口号</p>
<p>查看集群信息</p>
<p><img src="/2022/04/25/redis-bi-ji/image-20220424144329706.png" alt="image-20220424144329706"></p>
<p>16384就是槽</p>
<p>到现在cluster模式就搭建完成了</p>
<h4 id="Cluster模式原理分析"><a href="#Cluster模式原理分析" class="headerlink" title="Cluster模式原理分析"></a>Cluster模式原理分析</h4><p>​        Redis Cluster将所有数据划分为16384个slots(槽位)，每个节点负责其中一部分槽位。槽位的信息存储 于每个节点中。只有master节点会被分配槽位，slave节点不会分配槽位。</p>
<p>槽位定位算法： k1 &#x3D; 127001 </p>
<p>​        Cluster 默认会对 key 值使用 crc16 算法进行 hash 得到一个整数值，然后用这个整数值对 16384 进行取模来得到具体槽位。 </p>
<p>​        HASH_SLOT &#x3D; CRC16(key) % 16384</p>
<p>看我添加完就给我自动切换机器</p>
<p><img src="/2022/04/25/redis-bi-ji/image-20220424144942831.png" alt="image-20220424144942831"></p>
<p>要是不在这个槽位，他就获取不到</p>
<p>我一获取，又给我自动切换了19的机器</p>
<p><img src="/2022/04/25/redis-bi-ji/image-20220424145128067.png" alt="image-20220424145128067"></p>
<p>想把一堆数据放到同一个槽位里该怎么做？？</p>
<p><img src="/2022/04/25/redis-bi-ji/image-20220424145736419.png" alt="image-20220424145736419"></p>
<p>获取也要加括号</p>
<p><img src="/2022/04/25/redis-bi-ji/image-20220424145853865.png" alt="image-20220424145853865"></p>
<h5 id="故障恢复"><a href="#故障恢复" class="headerlink" title="故障恢复"></a>故障恢复</h5><p>myself代表就是当前连接的</p>
<p><img src="/2022/04/25/redis-bi-ji/image-20220424150008375.png" alt="image-20220424150008375"></p>
<p>现在来干掉17的master</p>
<p>lsof -i:8001</p>
<p>kill -9 PID</p>
<p>然后去另一台机器上查看</p>
<p><img src="/2022/04/25/redis-bi-ji/image-20220424150249548.png" alt="image-20220424150249548"></p>
<p>然后18的两个都是master了</p>
<h4 id="Java操作Redis集群"><a href="#Java操作Redis集群" class="headerlink" title="Java操作Redis集群"></a>Java操作Redis集群</h4><p>就是现在是cluster的集群</p>
<p>打开之前的redisdemo项目</p>
<pre class=" language-JAVA"><code class="language-JAVA">  @Test
    public void clusterTest() &#123;

        //构建Set集合保存redis节点
        Set<HostAndPort> redisNodes = new HashSet<>();
        redisNodes.add(new HostAndPort("192.168.8.17", 8001));
        redisNodes.add(new HostAndPort("192.168.8.17", 8002));
        redisNodes.add(new HostAndPort("192.168.8.18", 8001));
        redisNodes.add(new HostAndPort("192.168.8.18", 8002));
        redisNodes.add(new HostAndPort("192.168.8.19", 8001));
        redisNodes.add(new HostAndPort("192.168.8.19", 8002));

        //构建JedisCluster实例  建立连接
        JedisCluster jedisCluster = new JedisCluster(redisNodes);
        //添加元素
//        jedisCluster.set("name","JueJue");
        System.out.println(jedisCluster.get("name"));

    &#125;
</code></pre>
<p>针对Jedis完事</p>
<p><img src="/2022/04/25/redis-bi-ji/image-20220424151219473.png" alt="image-20220424151219473"></p>
<p>针对Springdata-redis</p>
<p>新建一个springboot项目</p>
<p>添加lombok和redis依赖</p>
<p>直接去把之前的配置文件拿过来改一下</p>
<pre class=" language-properties"><code class="language-properties"><span class="token comment" spellcheck="true">#Redis服务器连接地址</span>
<span class="token attr-name">spring.redis.host</span><span class="token punctuation">=</span><span class="token attr-value">192.168.8.11</span>
<span class="token comment" spellcheck="true">#Redis服务器连接端口</span>
<span class="token attr-name">spring.redis.port</span><span class="token punctuation">=</span><span class="token attr-value">6379</span>
<span class="token comment" spellcheck="true">#连接池最大连接数（使用负值表示没有限制）</span>
<span class="token attr-name">spring.redis.pool.max-active</span><span class="token punctuation">=</span><span class="token attr-value">8</span>
<span class="token comment" spellcheck="true">#连接池最大阻塞等待时间（使用负值表示没有限制）</span>
<span class="token attr-name">spring.redis.pool.max-wait</span><span class="token punctuation">=</span><span class="token attr-value">-1</span>
<span class="token comment" spellcheck="true">#连接池中的最大空闲连接</span>
<span class="token attr-name">spring.redis.pool.max-idle</span><span class="token punctuation">=</span><span class="token attr-value">8</span>
<span class="token comment" spellcheck="true">#连接池中的最小空闲连接</span>
<span class="token attr-name">spring.redis.pool.min-idle</span><span class="token punctuation">=</span><span class="token attr-value">0</span>
<span class="token comment" spellcheck="true">#连接超时时间（毫秒）</span>
<span class="token attr-name">spring.redis.timeout</span><span class="token punctuation">=</span><span class="token attr-value">30000</span>
</code></pre>
<p>就是原来是单机，现在改成cluster.nodes</p>
<pre class=" language-properties"><code class="language-properties"><span class="token comment" spellcheck="true">#Redis服务器连接地址</span>
<span class="token attr-name">spring.redis.cluster.nodes</span><span class="token punctuation">=</span><span class="token attr-value">192.168.8.17:8001,192.168.8.17:8002,192.168.8.18:8001,192.168.8.18:8002,192.168.8.19:8001,192.168.8.19:8002</span>
<span class="token comment" spellcheck="true">#Redis服务器连接端口</span>
<span class="token attr-name">spring.redis.port</span><span class="token punctuation">=</span><span class="token attr-value">6379</span>
<span class="token comment" spellcheck="true">#连接池最大连接数（使用负值表示没有限制）</span>
<span class="token attr-name">spring.redis.pool.max-active</span><span class="token punctuation">=</span><span class="token attr-value">8</span>
<span class="token comment" spellcheck="true">#连接池最大阻塞等待时间（使用负值表示没有限制）</span>
<span class="token attr-name">spring.redis.pool.max-wait</span><span class="token punctuation">=</span><span class="token attr-value">-1</span>
<span class="token comment" spellcheck="true">#连接池中的最大空闲连接</span>
<span class="token attr-name">spring.redis.pool.max-idle</span><span class="token punctuation">=</span><span class="token attr-value">8</span>
<span class="token comment" spellcheck="true">#连接池中的最小空闲连接</span>
<span class="token attr-name">spring.redis.pool.min-idle</span><span class="token punctuation">=</span><span class="token attr-value">0</span>
<span class="token comment" spellcheck="true">#连接超时时间（毫秒）</span>
<span class="token attr-name">spring.redis.timeout</span><span class="token punctuation">=</span><span class="token attr-value">30000</span>
</code></pre>
<p>一样也是可以的没难度的</p>
<p><img src="/2022/04/25/redis-bi-ji/image-20220424152043208.png" alt="image-20220424152043208"></p>
<h2 id="Redis企业级解决方案"><a href="#Redis企业级解决方案" class="headerlink" title="Redis企业级解决方案"></a>Redis企业级解决方案</h2><h3 id="Redis脑裂"><a href="#Redis脑裂" class="headerlink" title="Redis脑裂"></a>Redis脑裂</h3><p>出现在哨兵模式中</p>
<p>就是由于网络的原因，Master、Slave、Sentinel有延迟了</p>
<p>Sentinel问Master你还好吗，宕机没有，master不理，问了几次之后没理，就当你宕机，把slave重新升级成master，然后过一会网络好了，就有两个master，一山不容二虎，这就是redis脑裂问题，就是有两个master</p>
<h4 id="什么是Redis的集群脑裂"><a href="#什么是Redis的集群脑裂" class="headerlink" title="什么是Redis的集群脑裂"></a>什么是Redis的集群脑裂</h4><p>​        Redis的集群脑裂是指因为网络问题，导致Redis Master节点跟Redis slave节点和Sentinel集群处于不同 的网络分区，此时因为sentinel集群无法感知到master的存在，所以将slave节点提升为master节点。</p>
<p><img src="/2022/04/25/redis-bi-ji/image-20220424185227126.png" alt="image-20220424185227126"></p>
<h5 id="注意：-3"><a href="#注意：-3" class="headerlink" title="注意："></a>注意：</h5><p>此时存在两个不同的master节点，就像一个大脑分裂成了两个。集群脑裂问题中，如果客户端还 在基于原来的master节点继续写入数据，那么新的Master节点将无法同步这些数据，当网络问题 解决之后，sentinel集群将原先的Master节点降为slave节点，此时再从新的master中同步数据， 将会造成大量的数据丢失。</p>
<p>那客户端是连接新的master还是连接旧的？</p>
<p>出现脑裂现象会出现什么问题？</p>
<p>​        就是当Sentinel切换新master，新master就有写的功能，那有数据保存到新的master，原来的master是不是就会丢失一些数据</p>
<p>​    <strong>以后都可以这样理解，脑裂就是出现了两个主节点，解决方案不同技术不一样</strong></p>
<h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>配置两个参数就可以</p>
<p>redis.conf配置参数：</p>
<pre class=" language-none"><code class="language-none">min-replicas-to-write 1
min-replicas-max-lag 5
</code></pre>
<h5 id="参数：-2"><a href="#参数：-2" class="headerlink" title="参数："></a>参数：</h5><p>第一个参数表示最少的slave节点为1个 </p>
<p>第二个参数表示数据复制和同步的延迟不能超过5秒</p>
<p><strong>配置了这两个参数：如果发生脑裂原Master会在客户端写入操作的时候拒绝请求。这样可以避免大量数据丢失。</strong></p>
<h3 id="缓存预热"><a href="#缓存预热" class="headerlink" title="缓存预热"></a>缓存预热</h3><h4 id="缓存冷启动"><a href="#缓存冷启动" class="headerlink" title="缓存冷启动"></a>缓存冷启动</h4><p>​        缓存中没有数据，由于缓存冷启动一点数据都没有，如果直接就对外提供服务了，那么并发量上来 Mysql就裸奔挂掉了。</p>
<p><img src="/2022/04/25/redis-bi-ji/image-20220424185419139.png" alt="image-20220424185419139"></p>
<p>缓存中没有数据，直接对外服务并发量上来数据库一下就挂掉</p>
<p>提前在redis放缓存就是缓存预热</p>
<h4 id="缓存冷启动场景"><a href="#缓存冷启动场景" class="headerlink" title="缓存冷启动场景"></a>缓存冷启动场景</h4><p>​        新启动的系统没有任何缓存数据，在缓存重建数据的过程中，系统性能和数据库负载都不太好，所以最 好是在系统上线之前就把要缓存的热点数据加载到缓存中，这种缓存预加载手段就是缓存预热</p>
<p><img src="/2022/04/25/redis-bi-ji/image-20220424185449907.png" alt="image-20220424185449907"></p>
<h4 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h4><ul>
<li>提前给redis中灌入部分数据，再提供服务 </li>
<li>如果数据量非常大，<strong>就不可能将所有数据都写入redis</strong>，因为数据量太大了，第一是因为耗费的时间太长了，第二根本redis容纳不下所有的数据 </li>
<li>需要根据当天的具体访问情况，实时<strong>统计出访问频率较高的热数据</strong> </li>
<li>然后将访问频率较高的热数据写入redis中，肯定是热数据也比较多，我们也得多个服务并行读取数据去写，并行的分布式的缓存预热</li>
</ul>
<p><img src="/2022/04/25/redis-bi-ji/image-20220424185606718.png" alt="image-20220424185606718"></p>
<p>​        lua语言把Nginx日志直接发给消息中间件（只是一种解决方案），然后通过Storm（实时框架）统计访问次数,然后根据结果将热门的加到缓存中就好了</p>
<h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><p><img src="/2022/04/25/redis-bi-ji/image-20220424185709595.png" alt="image-20220424185709595"></p>
<p>缓存穿透就是用户对不存在的数据发起请求</p>
<h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>​        <strong>缓存穿透是指缓存和数据库中都没有的数据</strong>，而用户不断发起请求，如发起为id为“-1”的数据或id为特别 大不存在的数据。这时的用户很可能是攻击者，攻击会导致数据库压力过大。</p>
<h6 id="解释："><a href="#解释：" class="headerlink" title="解释："></a>解释：</h6><p>​        缓存穿透是指用户查询数据，在数据库没有，自然在缓存中也不会有。这样就导致用户查询的时候，在缓存中找不到，每次都要去数据库再查询一遍，然后返回空（相当于进行了两次无用的查 询）。这样请求就绕过缓存直接查数据库，这也是经常提的缓存命中率问题。</p>
<h4 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h4><p><strong>1.对空值缓存：</strong>如果一个查询返回的数据为空（不管数据是否存在），我们仍然把这个空结果缓存， 设置空结果的过期时间会很短，最长不超过5分钟。</p>
<p><strong>2.布隆过滤器：</strong>如果想判断一个元素是不是在一个集合里，一般想到的是将集合中所有元素保存起来，然后通过比较确定。</p>
<h5 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h5><p>–byte数组实现</p>
<p>​        布隆过滤器是一种数据结构，比较巧妙的概率型数据结构（probabilistic data structure），特点是高效 地插入和查询，可以用来告诉你 “某样东西一定不存在或者可能存在”。</p>
<p><img src="/2022/04/25/redis-bi-ji/image-20220424185908110.png" alt="image-20220424185908110"></p>
<p>​    比如先放了个西瓜和香蕉，苹果不存在，但是它的hash值和对上了</p>
<p>注意： 布隆说不存在一定不存在，布隆说存在你要小心了，它有可能不存在。</p>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><p>引入hutool包  </p>
<pre class=" language-xml"><code class="language-xml">   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>cn.hutool<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>hutool-all<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>5.7.17<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>
   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>
</code></pre>
<p>可以在项目启动的时候把所有商品的id查询出来放进去布隆过滤器里面</p>
<pre class=" language-JAVA"><code class="language-JAVA">@Test
public void FilterTest()&#123;

    //初始化
    BitMapBloomFilter bitMapBloomFilter = new BitMapBloomFilter(10);
    //添加元素
    bitMapBloomFilter.add("abc");
    bitMapBloomFilter.add("123");
    bitMapBloomFilter.add("juejue");
    bitMapBloomFilter.add("qwe");

    System.out.println(bitMapBloomFilter.contains("789"));
    System.out.println(bitMapBloomFilter.contains("abc"));

&#125;
</code></pre>
<h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3><p>缓存击穿是指缓存中没有但数据库中有的单条数据</p>
<h5 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h5><p>​        某一个热点 key，在缓存过期的一瞬间，同时有大量的请求打进来，由于此时缓存过期了，所以请求最 终都会走到数据库，造成瞬时数据库请求量大、压力骤增，甚至可能打垮数据库。</p>
<h4 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案"></a>解决方案</h4><p><strong>1.互斥锁：</strong></p>
<p>​    在并发的多个请求中，只有第一个请求线程能拿到锁并执行数据库查询操作，其他的线程 拿不到锁就阻塞等着，等到第一个线程将数据写入缓存后，其他线程直接查询缓存。 </p>
<p><strong>2.热点数据不过期：</strong></p>
<p>​    直接将缓存设置为不过期，然后由定时任务去异步加载数据，更新缓存。</p>
<h5 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h5><pre class=" language-JAVA"><code class="language-JAVA">/**
 * 互斥锁解决缓存击穿
 *
 * @param key 商品key
 */
@Test
public String lock(String key) throws InterruptedException &#123;
    //获取key的值
    String value = jedis.get(key);
    //判断缓存是否过期
    if (value == null) &#123;
        //设置3分钟的超时时间，只有key不存在时候才能创建
        Long setnx = jedis.setnx(key + "_mutex", "6");
        //设置过期时间
        jedis.pexpire(key + "_mutex", 3 * 60);
        //设置成功
        if (setnx == 1) &#123;
            //DB操作
            value = "db";
            //保存缓存
            jedis.setex(key,3*60,value);

            jedis.del(key + "_mutex");
            return value;
        &#125;else &#123;
            // 这个时候代表同时操作的其他线程已经load db并设置缓存了。 需要重新重新获取缓存
            Thread.sleep(5000);
            //重试
            return lock(key);
        &#125;
    &#125;else &#123;
        return value;
    &#125;
&#125;
</code></pre>
<h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><p>​    缓存雪崩发生时说明缓存中大批量的数据过期，而查询量巨大，请求直接到达数据库，造成数据库压力倍增</p>
<h5 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h5><p>​        缓存雪崩是指在我们设置缓存时采用了相同的过期时间，导致缓存在某一时刻同时失效，请求全部转发 到DB，DB瞬时压力过重雪崩。</p>
<p>缓存正常从Redis中获取，示意图如下：</p>
<p><img src="/2022/04/25/redis-bi-ji/image-20220424195855987.png" alt="image-20220424195855987"></p>
<p>缓存失效瞬间示意图如下：</p>
<p><img src="/2022/04/25/redis-bi-ji/image-20220424195913256.png" alt="image-20220424195913256"></p>
<h5 id="解决方案-3"><a href="#解决方案-3" class="headerlink" title="解决方案"></a>解决方案</h5><ul>
<li><strong>过期时间打散：</strong>既然是大量缓存集中失效，那最容易想到就是让他们不集中生效。可以给缓存的过 期时间时加上一个随机值时间，使得每个 key 的过期时间分布开来，不会集中在同一时刻失效。 </li>
<li><strong>热点数据不过期：</strong>该方式和缓存击穿一样，也是要着重考虑刷新的时间间隔和数据异常如何处理的情况。</li>
<li><strong>加互斥锁:</strong> 该方式和缓存击穿一样，按 key 维度加锁，对于同一个 key，只允许一个线程去计算， 其他线程原地阻塞等待第一个线程的计算结果，然后直接走缓存即可。</li>
</ul>
<h6 id="加锁排队代码"><a href="#加锁排队代码" class="headerlink" title="加锁排队代码"></a>加锁排队代码</h6><pre class=" language-JAVA"><code class="language-JAVA">/**
 * 互斥锁解决缓存击穿
 *
 * @param key 商品key
 */
@Test
public String lock(String key) throws InterruptedException &#123;
    //获取key的值
    String value = jedis.get(key);
    //判断缓存是否过期
    if (value == null) &#123;
        //设置3分钟的超时时间，只有key不存在时候才能创建
        Long setnx = jedis.setnx(key + "_mutex", "6");
        //设置过期时间
        jedis.pexpire(key + "_mutex", 3 * 60);
        //设置成功
        if (setnx == 1) &#123;
            //DB操作
            value = "db";
            //保存缓存
            jedis.setex(key,3*60,value);

            jedis.del(key + "_mutex");
            return value;
        &#125;else &#123;
            Thread.sleep(5000);
            //重试
            return lock(key);
        &#125;
    &#125;else &#123;
        return value;
    &#125;
&#125;
</code></pre>
<h3 id="Redis开发规范"><a href="#Redis开发规范" class="headerlink" title="Redis开发规范"></a>Redis开发规范</h3><h4 id="key设计技巧"><a href="#key设计技巧" class="headerlink" title="key设计技巧"></a>key设计技巧</h4><ul>
<li>1、把表名转换为key前缀，如 tag: </li>
<li>2、把第二段放置用于区分key的字段，对应msyql中主键的列名，如 user_id </li>
<li>3、第三段放置主键值，如 2,3,4 </li>
<li>4、第四段写存储的列名</li>
</ul>
<h5 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h5><pre><code># 表名 主键 主键值 存储列名字
set user:user_id:1:name JueJue
set user:user_id:1:age 20
#查询这个用户
keys user:user_id:9*
</code></pre>
<p>冒号的方式你打开管理工具看缓存就有层级目录</p>
<p><img src="/2022/04/25/redis-bi-ji/image-20220424170722693.png" alt="image-20220424170722693"></p>
<p><strong>要是有业务的话，在表名前面加一个业务名就可以</strong></p>
<h4 id="value设计"><a href="#value设计" class="headerlink" title="value设计"></a>value设计</h4><h5 id="拒绝bigkey"><a href="#拒绝bigkey" class="headerlink" title="拒绝bigkey"></a>拒绝bigkey</h5><p>​        防止网卡流量、慢查询，string类型控制在10KB以内，hash、list、set、zset元素个数不要超过5000。</p>
<h4 id="命令使用"><a href="#命令使用" class="headerlink" title="命令使用"></a>命令使用</h4><h5 id="1、禁用命令"><a href="#1、禁用命令" class="headerlink" title="1、禁用命令"></a>1、禁用命令</h5><p>​        禁止线上使用keys、flushall、flushdb等，通过redis的rename机制禁掉命令，或者使用scan的方式渐 进式处理。 </p>
<h5 id="2、合理使用select"><a href="#2、合理使用select" class="headerlink" title="2、合理使用select"></a>2、合理使用select</h5><p>​        redis的多数据库较弱，使用数字进行区分，很多客户端支持较差，同时多业务用多数据库实际还是单线 程处理，会有干扰。</p>
<h5 id="3、使用批量操作提高效率"><a href="#3、使用批量操作提高效率" class="headerlink" title="3、使用批量操作提高效率"></a>3、使用批量操作提高效率</h5><h6 id="原生命令："><a href="#原生命令：" class="headerlink" title="原生命令："></a>原生命令：</h6><p>​    例如mget、mset。 </p>
<h6 id="非原生命令："><a href="#非原生命令：" class="headerlink" title="非原生命令："></a>非原生命令：</h6><p>​    可以使用pipeline提高效率。pipeline方式，就很快</p>
<h6 id="注意：-4"><a href="#注意：-4" class="headerlink" title="注意："></a>注意：</h6><p>​    但要注意控制一次批量操作的元素个数(例如500以内，实际也和元素字节数有关)。</p>
<h5 id="4、不建议过多使用Redis事务功能"><a href="#4、不建议过多使用Redis事务功能" class="headerlink" title="4、不建议过多使用Redis事务功能"></a>4、不建议过多使用Redis事务功能</h5><p>​    Redis的事务功能较弱(不支持回滚)，而且集群版本(自研和官方)要求一次事务操作的key必须在一个slot 上。</p>
<p>集群版本要求就是在一个槽上</p>
<h4 id="客户端使用"><a href="#客户端使用" class="headerlink" title="客户端使用"></a>客户端使用</h4><p>1.Jedis ：<a target="_blank" rel="noopener" href="https://github.com/xetorthio/jedis">https://github.com/xetorthio/jedis</a> 重点推荐 </p>
<p>2.Spring Data redis ：<a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-data-redis">https://github.com/spring-projects/spring-data-redis</a> 使用Spring框架时推荐 3.Redisson ：<a target="_blank" rel="noopener" href="https://github.com/mrniko/redisson">https://github.com/mrniko/redisson</a> 分布式锁、阻塞队列的时重点推荐 </p>
<h6 id="1、避免多个应用使用一个Redis实例"><a href="#1、避免多个应用使用一个Redis实例" class="headerlink" title="1、避免多个应用使用一个Redis实例"></a>1、避免多个应用使用一个Redis实例</h6><p>​    不相干的业务拆分，公共数据做服务化。 </p>
<h6 id="2、使用连接池"><a href="#2、使用连接池" class="headerlink" title="2、使用连接池"></a>2、使用连接池</h6><p>​    可以有效控制连接，同时提高效率，标准使用方式:</p>
<pre class=" language-JAVA"><code class="language-JAVA">执行命令如下：
Jedis jedis = null;
try &#123;
    jedis = jedisPool.getResource();
//具体的命令
    jedis.executeCommand()
&#125; catch (Exception e) &#123;
    logger.error("op key &#123;&#125; error: " + e.getMessage(), key, e);
&#125; finally &#123;
//注意这里不是关闭连接，在JedisPool模式下，Jedis会被归还给资源池。
if (jedis != null)
    jedis.close();
&#125;
</code></pre>
<h3 id="数据一致性"><a href="#数据一致性" class="headerlink" title="数据一致性"></a>数据一致性</h3><p><img src="/2022/04/25/redis-bi-ji/image-20220424202532521.png" alt="image-20220424202532521"></p>
<p>就是查缓存了查笔记本，然后同时又有请求去修改这个笔记本，所以这就数据不一致了</p>
<p>缓存说明： 从理论上来说，给缓存设置过期时间，是保证最终一致性的解决方案。</p>
<p><strong>缓存不一致理论上来说是可以设置过期时间来保证一致性的；越短越能保证</strong></p>
<h4 id="三种更新策略"><a href="#三种更新策略" class="headerlink" title="三种更新策略"></a>三种更新策略</h4><ul>
<li>先更新数据库，再更新缓存 </li>
<li>先删除缓存，再更新数据库 </li>
<li>先更新数据库，再删除缓存</li>
</ul>
<p>我们还是得以数据库中的数据为准</p>
<h5 id="先更新数据库，再更新缓存"><a href="#先更新数据库，再更新缓存" class="headerlink" title="先更新数据库，再更新缓存"></a>先更新数据库，再更新缓存</h5><p>这套方案，大家是普遍反对的。为什么呢？ </p>
<h6 id="线程安全角度"><a href="#线程安全角度" class="headerlink" title="线程安全角度"></a>线程安全角度</h6><p>同时有请求A和请求B进行更新操作，那么会出现 </p>
<p>（1）线程A更新了数据库 </p>
<p>（2）线程B更新了数据库 </p>
<p>（3）线程B更新了缓存 </p>
<p>（4）线程A更新了缓存 这就出现请求A更新缓存应该比请求B更新缓存早才对，但是因为网络等原因，B却比A更早更新了缓存。 这就导致了脏数据，因此不考虑。</p>
<h5 id="先删缓存，再更新数据库"><a href="#先删缓存，再更新数据库" class="headerlink" title="先删缓存，再更新数据库"></a>先删缓存，再更新数据库</h5><p>​    该方案会导致不一致的原因是。同时有一个请求A进行更新操作，另一个请求B进行查询操作。那么会出 现如下情形: </p>
<p>（1）请求A进行写操作，删除缓存 </p>
<p>（2）请求B查询发现缓存不存在 </p>
<p>（3）请求B去数据库查询得到旧值 </p>
<p>（4）请求B将旧值写入缓存 </p>
<p>（5）请求A将新值写入数据库 </p>
<p>注意： </p>
<p>该数据永远都是脏数据。</p>
<h5 id="先更新数据库，再延时删缓存-正解"><a href="#先更新数据库，再延时删缓存-正解" class="headerlink" title="先更新数据库，再延时删缓存(正解)"></a>先更新数据库，再延时删缓存(正解)</h5><p><img src="/2022/04/25/redis-bi-ji/image-20220424204451253.png" alt="image-20220424204451253"></p>
<p>这种情况存在并发问题吗？ </p>
<p>（1）缓存刚好失效 </p>
<p>（2）请求A查询数据库，得一个旧值 </p>
<p>（3）请求B将新值写入数据库 </p>
<p>（4）请求B删除缓存 </p>
<p>（5）请求A将查到的旧值写入缓存</p>
<p>发生这种情况的概率又有多少? </p>
<p>​        发生上述情况有一个先天性条件，就是步骤（3）的写数据库操作比步骤（2）的读数据库操作耗 时更短，才有可能使得步骤（4）先于步骤（5）。可是，大家想想，数据库的读操作的速度远快 于写操作的，因此步骤（3）耗时比步骤（2）更短，这一情形很难出现</p>
<p>加过期时间</p>
<p>先更新数据库，在删除缓存，而且删除缓存是延时的删除缓存</p>
<p>就是缓存添加成功后等个1s再删掉</p>

                
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">JueJue</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="http://zg-jian.github.io/2022/04/25/redis-bi-ji/">http://zg-jian.github.io/2022/04/25/redis-bi-ji/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="/about" target="_blank">JueJue</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/DB/">
                                    <span class="chip bg-color">DB</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="qq,qzone,wechat,weibo" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
        </div>
    </div>

    

    

    

    

    
        <style>
    .valine-card {
        margin: 1.5rem auto;
    }

    .valine-card .card-content {
        padding: 20px 20px 5px 20px;
    }

    #vcomments textarea {
        box-sizing: border-box;
        background: url("/medias/comment_bg.png") 100% 100% no-repeat;
    }

    #vcomments p {
        margin: 2px 2px 10px;
        font-size: 1.05rem;
        line-height: 1.78rem;
    }

    #vcomments blockquote p {
        text-indent: 0.2rem;
    }

    #vcomments a {
        padding: 0 2px;
        color: #4cbf30;
        font-weight: 500;
        text-decoration: none;
    }

    #vcomments img {
        max-width: 100%;
        height: auto;
        cursor: pointer;
    }

    #vcomments ol li {
        list-style-type: decimal;
    }

    #vcomments ol,
    ul {
        display: block;
        padding-left: 2em;
        word-spacing: 0.05rem;
    }

    #vcomments ul li,
    ol li {
        display: list-item;
        line-height: 1.8rem;
        font-size: 1rem;
    }

    #vcomments ul li {
        list-style-type: disc;
    }

    #vcomments ul ul li {
        list-style-type: circle;
    }

    #vcomments table, th, td {
        padding: 12px 13px;
        border: 1px solid #dfe2e5;
    }

    #vcomments table, th, td {
        border: 0;
    }

    table tr:nth-child(2n), thead {
        background-color: #fafafa;
    }

    #vcomments table th {
        background-color: #f2f2f2;
        min-width: 80px;
    }

    #vcomments table td {
        min-width: 80px;
    }

    #vcomments h1 {
        font-size: 1.85rem;
        font-weight: bold;
        line-height: 2.2rem;
    }

    #vcomments h2 {
        font-size: 1.65rem;
        font-weight: bold;
        line-height: 1.9rem;
    }

    #vcomments h3 {
        font-size: 1.45rem;
        font-weight: bold;
        line-height: 1.7rem;
    }

    #vcomments h4 {
        font-size: 1.25rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    #vcomments h5 {
        font-size: 1.1rem;
        font-weight: bold;
        line-height: 1.4rem;
    }

    #vcomments h6 {
        font-size: 1rem;
        line-height: 1.3rem;
    }

    #vcomments p {
        font-size: 1rem;
        line-height: 1.5rem;
    }

    #vcomments hr {
        margin: 12px 0;
        border: 0;
        border-top: 1px solid #ccc;
    }

    #vcomments blockquote {
        margin: 15px 0;
        border-left: 5px solid #42b983;
        padding: 1rem 0.8rem 0.3rem 0.8rem;
        color: #666;
        background-color: rgba(66, 185, 131, .1);
    }

    #vcomments pre {
        font-family: monospace, monospace;
        padding: 1.2em;
        margin: .5em 0;
        background: #272822;
        overflow: auto;
        border-radius: 0.3em;
        tab-size: 4;
    }

    #vcomments code {
        font-family: monospace, monospace;
        padding: 1px 3px;
        font-size: 0.92rem;
        color: #e96900;
        background-color: #f8f8f8;
        border-radius: 2px;
    }

    #vcomments pre code {
        font-family: monospace, monospace;
        padding: 0;
        color: #e8eaf6;
        background-color: #272822;
    }

    #vcomments pre[class*="language-"] {
        padding: 1.2em;
        margin: .5em 0;
    }

    #vcomments code[class*="language-"],
    pre[class*="language-"] {
        color: #e8eaf6;
    }

    #vcomments [type="checkbox"]:not(:checked), [type="checkbox"]:checked {
        position: inherit;
        margin-left: -1.3rem;
        margin-right: 0.4rem;
        margin-top: -1px;
        vertical-align: middle;
        left: unset;
        visibility: visible;
    }

    #vcomments b,
    strong {
        font-weight: bold;
    }

    #vcomments dfn {
        font-style: italic;
    }

    #vcomments small {
        font-size: 85%;
    }

    #vcomments cite {
        font-style: normal;
    }

    #vcomments mark {
        background-color: #fcf8e3;
        padding: .2em;
    }

    #vcomments table, th, td {
        padding: 12px 13px;
        border: 1px solid #dfe2e5;
    }

    table tr:nth-child(2n), thead {
        background-color: #fafafa;
    }

    #vcomments table th {
        background-color: #f2f2f2;
        min-width: 80px;
    }

    #vcomments table td {
        min-width: 80px;
    }

    #vcomments [type="checkbox"]:not(:checked), [type="checkbox"]:checked {
        position: inherit;
        margin-left: -1.3rem;
        margin-right: 0.4rem;
        margin-top: -1px;
        vertical-align: middle;
        left: unset;
        visibility: visible;
    }
</style>

<div class="card valine-card" data-aos="fade-up">
    <div class="comment_headling" style="font-size: 20px; font-weight: 700; position: relative; padding-left: 20px; top: 15px; padding-bottom: 5px;">
        <i class="fas fa-comments fa-fw" aria-hidden="true"></i>
        <span>评论</span>
    </div>
    <div id="vcomments" class="card-content" style="display: grid">
    </div>
</div>

<script src="/libs/valine/av-min.js"></script>
<script src="/libs/valine/Valine.min.js"></script>
<script>
    new Valine({
        el: '#vcomments',
        appId: '7NFhD3OrhhYKm8uII0IYQzr8-gzGzoHsz',
        appKey: 'uebYYTaY9LiGMshkU3IHEDBT',
        notify: 'false' === 'true',
        verify: 'false' === 'true',
        visitor: 'true' === 'true',
        avatar: 'mm',
        pageSize: '10',
        lang: 'zh-cn',
        placeholder: '与君共勉！！'
    });
</script>

<!--酷Q推送-->


    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2022/05/05/shi-yong-navicat-lian-jie-docker-rong-qi-zhong-de-mysql-bao-cuo-10060-unknow-error/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/5.jpg" class="responsive-img" alt="使用Navicat连接docker容器中的mysql报错10060：unknow error">
                        
                        <span class="card-title">使用Navicat连接docker容器中的mysql报错10060：unknow error</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            重启虚拟机再重新启动容器
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2022-05-05
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/Linux/" class="post-category">
                                    Linux
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E5%B0%8F%E9%97%AE%E9%A2%98/">
                        <span class="chip bg-color">小问题</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2022/04/19/fastdfs-bi-ji/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/1.jpg" class="responsive-img" alt="FastDFS笔记">
                        
                        <span class="card-title">FastDFS笔记</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            分布式文件系统
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2022-04-19
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/" class="post-category">
                                    分布式
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>


<script>
    $('#articleContent').on('copy', function (e) {
        // IE8 or earlier browser is 'undefined'
        if (typeof window.getSelection === 'undefined') return;

        var selection = window.getSelection();
        // if the selection is short let's not annoy our users.
        if (('' + selection).length < Number.parseInt('30')) {
            return;
        }

        // create a div outside of the visible area and fill it with the selected text.
        var bodyElement = document.getElementsByTagName('body')[0];
        var newdiv = document.createElement('div');
        newdiv.style.position = 'absolute';
        newdiv.style.left = '-99999px';
        bodyElement.appendChild(newdiv);
        newdiv.appendChild(selection.getRangeAt(0).cloneContents());

        // we need a <pre> tag workaround.
        // otherwise the text inside "pre" loses all the line breaks!
        if (selection.getRangeAt(0).commonAncestorContainer.nodeName === 'PRE' || selection.getRangeAt(0).commonAncestorContainer.nodeName === 'CODE') {
            newdiv.innerHTML = "<pre>" + newdiv.innerHTML + "</pre>";
        }

        var url = document.location.href;
        newdiv.innerHTML += '<br />'
            + '来源: Jue-Blog<br />'
            + '文章作者: JueJue<br />'
            + '文章链接: <a href="' + url + '">' + url + '</a><br />'
            + '本文章著作权归作者所有，任何形式的转载都请注明出处。';

        selection.selectAllChildren(newdiv);
        window.setTimeout(function () {bodyElement.removeChild(newdiv);}, 200);
    });
</script>


<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    
        <link rel="stylesheet" href="/libs/aplayer/APlayer.min.css">
<style>
    .aplayer .aplayer-lrc p {
        
        display: none;
        
        font-size: 12px;
        font-weight: 700;
        line-height: 16px !important;
    }

    .aplayer .aplayer-lrc p.aplayer-lrc-current {
        
        display: none;
        
        font-size: 15px;
        color: #42b983;
    }

    
    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {
        left: -66px !important;
    }

    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {
        left: 0px !important;
    }

    
</style>
<div class="">
    
    <div class="row">
        <meting-js class="col l8 offset-l2 m10 offset-m1 s12"
                   server="netease"
                   type="playlist"
                   id="503838841"
                   fixed='true'
                   autoplay='false'
                   theme='#42b983'
                   loop='all'
                   order='random'
                   preload='auto'
                   volume='0.7'
                   list-folded='true'
        >
        </meting-js>
    </div>
</div>

<script src="/libs/aplayer/APlayer.min.js"></script>
<script src="/libs/aplayer/Meting.min.js"></script>

    

    <div class="container row center-align"
         style="margin-bottom: 15px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2022</span>
            
            <a href="/about" target="_blank">JueJue</a>
            |&nbsp;Powered by&nbsp;<a href="https://zg-jian.github.io" target="_blank">JueJue</a>
            <br>
            
                &nbsp;<i class="fas fa-chart-area"></i>&nbsp;站点总字数:&nbsp;<span
                        class="white-color">49k</span>
            
            
            
                
            
            
                <span id="busuanzi_container_site_pv">
                &nbsp;|&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;
                    <span id="busuanzi_value_site_pv" class="white-color"></span>
            </span>
            
            
                <span id="busuanzi_container_site_uv">
                &nbsp;|&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;
                    <span id="busuanzi_value_site_uv" class="white-color"></span>
            </span>
            
            <br>

            <!-- 运行天数提醒. -->
            
                <span id="sitetime"> Loading ...</span>
                <script>
                    var calcSiteTime = function () {
                        var seconds = 1000;
                        var minutes = seconds * 60;
                        var hours = minutes * 60;
                        var days = hours * 24;
                        var years = days * 365;
                        var today = new Date();
                        var startYear = "2022";
                        var startMonth = "3";
                        var startDate = "27";
                        var startHour = "8";
                        var startMinute = "25";
                        var startSecond = "6";
                        var todayYear = today.getFullYear();
                        var todayMonth = today.getMonth() + 1;
                        var todayDate = today.getDate();
                        var todayHour = today.getHours();
                        var todayMinute = today.getMinutes();
                        var todaySecond = today.getSeconds();
                        var t1 = Date.UTC(startYear, startMonth, startDate, startHour, startMinute, startSecond);
                        var t2 = Date.UTC(todayYear, todayMonth, todayDate, todayHour, todayMinute, todaySecond);
                        var diff = t2 - t1;
                        var diffYears = Math.floor(diff / years);
                        var diffDays = Math.floor((diff / days) - diffYears * 365);

                        // 区分是否有年份.
                        var language = 'zh-CN';
                        if (startYear === String(todayYear)) {
                            document.getElementById("year").innerHTML = todayYear;
                            var daysTip = 'This site has been running for ' + diffDays + ' days';
                            if (language === 'zh-CN') {
                                daysTip = '本站已运行 ' + diffDays + ' 天';
                            } else if (language === 'zh-HK') {
                                daysTip = '本站已運行 ' + diffDays + ' 天';
                            }
                            document.getElementById("sitetime").innerHTML = daysTip;
                        } else {
                            document.getElementById("year").innerHTML = startYear + " - " + todayYear;
                            var yearsAndDaysTip = 'This site has been running for ' + diffYears + ' years and '
                                + diffDays + ' days';
                            if (language === 'zh-CN') {
                                yearsAndDaysTip = '本站已运行 ' + diffYears + ' 年 ' + diffDays + ' 天';
                            } else if (language === 'zh-HK') {
                                yearsAndDaysTip = '本站已運行 ' + diffYears + ' 年 ' + diffDays + ' 天';
                            }
                            document.getElementById("sitetime").innerHTML = yearsAndDaysTip;
                        }
                    }

                    calcSiteTime();
                </script>
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/ZG-jian" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:2826022861@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>







    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=2826022861" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 2826022861" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>







</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    

    

    <!-- 雪花特效 -->
    

    <!-- 鼠标星星特效 -->
    

     
        <script src="https://ssl.captcha.qq.com/TCaptcha.js"></script>
        <script src="/libs/others/TencentCaptcha.js"></script>
        <button id="TencentCaptcha" data-appid="xxxxxxxxxx" data-cbfn="callback" type="button" hidden></button>
    

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="/libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

    <!--腾讯兔小巢-->
    
    

    

    
    <script type="text/javascript" src="/libs/background/ribbon-dynamic.js" async="async"></script>
    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
